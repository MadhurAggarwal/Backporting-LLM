{"question": "What changes were made to the handling of the 'expires' attribute in the 'parse_one_cookie' function of the file 'libsoup/cookies/soup-cookie.c'?", "answer": "The line 'soup_cookie_set_expires(cookie, parse_date(&p));' was replaced with 'g_clear_pointer(&cookie->expires, g_date_time_unref); cookie->expires = parse_date(&p);'."}
{"question": "What is the new implementation for clearing the 'expires' attribute in the 'parse_one_cookie' function of 'libsoup/cookies/soup-cookie.c'?", "answer": "The 'expires' attribute is now cleared using 'g_clear_pointer(&cookie->expires, g_date_time_unref);' before assigning a new value."}
{"question": "What is the new version number of the 'libsoup' project in the 'meson.build' file?", "answer": "New version: '3.6.1', Previous version: '3.6.0'."}
{"question": "What changes were made to the 'NEWS' file regarding the 'libsoup_uri_copy()' function?", "answer": "Added note: Fix reading port as a long instead of an int."}
{"question": "What changes were made to the 'NEWS' file regarding the 'soup_uri_decode_data_uri()' function?", "answer": "Added note: Fix possible NULL dereference and assertion on paths starting with '//'."}
{"question": "What changes were made to the 'NEWS' file regarding the 'SoupContentSniffer'?", "answer": "Added note: Fix possible overflow."}
{"question": "What changes were made to the 'NEWS' file regarding the 'headers' parsing?", "answer": "Added note: Be more robust against invalid input when parsing params."}
{"question": "What changes were made to the 'NEWS' file regarding the 'websocket' functionality?", "answer": "Added note: Fix possibility of being stuck in a read loop."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 669\n    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)\n    HUNK_START_LINE_CONTENT: pos = 3;\n    FIRST_CHANGED_LINE_NUMBER: 671\n    FIRST_CHANGED_LINE_CONTENT: if (pos >= resource_length)\n    HUNK_LINES:\n        pos = 3;\n\nlook_for_tag:\n-    if (pos > resource_length)\n+    if (pos >= resource_length)\n        goto text_html;\n\n    if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 669\n    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)\n    HUNK_START_LINE_CONTENT: pos = 3;\n    FIRST_CHANGED_LINE_NUMBER: 671\n    FIRST_CHANGED_LINE_CONTENT: if (pos >= resource_length)\n    HUNK_LINES:\n        pos = 3;\n\nlook_for_tag:\n-    if (pos > resource_length)\n+    if (pos >= resource_length)\n        goto text_html;\n\n    if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT: gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT: const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n    +        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT: gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT: const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n    +        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT: if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 305\n    FIRST_CHANGED_LINE_CONTENT: path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n    +        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n    +        path = g_uri_get_path (soup_uri);\n    +        if (path[0] == '/' && path[1] == '/') {\n    +                g_uri_unref (soup_uri);\n    +                return NULL;\n    +        }\n    +\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT: if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 305\n    FIRST_CHANGED_LINE_CONTENT: path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n    +        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n    +        path = g_uri_get_path (soup_uri);\n    +        if (path[0] == '/' && path[1] == '/') {\n    +                g_uri_unref (soup_uri);\n    +                return NULL;\n    +        }\n    +\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;"}
{"question": "Was a new language added to the translation list in the file 'po/LINGUAS'?", "answer": "Yes, 'uz' (Uzbek Latin) was added."}
{"question": "Was a new translation file added in the 'po' directory?", "answer": "Yes, 'uz.po' for Uzbek (Latin) was added."}
{"question": "What is the content of the newly added translation file 'po/uz.po'?", "answer": "The file contains Uzbek (Latin) translations for various strings in the libsoup package."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 148\n    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,\n    HUNK_START_LINE_CONTENT:     guint qop_options;\n    FIRST_CHANGED_LINE_NUMBER: 150\n    FIRST_CHANGED_LINE_CONTENT:         if (!soup_auth_get_realm (auth))\n    HUNK_LINES:\n        guint qop_options;\n        gboolean ok = TRUE;\n\n+        if (!soup_auth_get_realm (auth))\n+                return FALSE;\n+\n        g_free (priv->domain);\n        g_free (priv->nonce);\n        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 148\n    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,\n    HUNK_START_LINE_CONTENT:     guint qop_options;\n    FIRST_CHANGED_LINE_NUMBER: 150\n    FIRST_CHANGED_LINE_CONTENT:         if (!soup_auth_get_realm (auth))\n    HUNK_LINES:\n        guint qop_options;\n        gboolean ok = TRUE;\n\n+        if (!soup_auth_get_realm (auth))\n+                return FALSE;\n+\n        g_free (priv->domain);\n        g_free (priv->nonce);\n        g_free (priv->opaque);"}
{"question": "What changes were made to the conditional logic in the function located in 'libsoup/http1/soup-body-input-stream.c' at line 244?", "answer": "The conditional logic was updated to correctly detect chunked trailers end by modifying the 'if' statement."}
{"question": "What is the updated logic for detecting chunked trailers in 'libsoup/http1/soup-body-input-stream.c'?", "answer": "Updated logic: 'if ((nread == 2 && strncmp (metabuf, \"\\r\\n\", nread) == 0) || (nread == 1 && strncmp (metabuf, \"\\n\", nread) == 0))'."}
{"question": "Has the file path of 'libsoup/soup-cache-input-stream.c' changed? What is the new path?", "answer": "Yes, new path: 'libsoup/cache/soup-cache-input-stream.c'"}
{"question": "Has the file path of 'libsoup/soup-converter-wrapper.c' changed? What is the new path?", "answer": "Yes, new path: 'libsoup/content-decoder/soup-converter-wrapper.c'"}
{"question": "Has the file path of 'libsoup/soup-message-client-io.c' changed? What is the new path?", "answer": "Yes, new path: 'libsoup/http1/soup-client-message-io-http1.c'"}
{"question": "Has the file path of 'libsoup/soup-message-io.c' changed? What is the new path?", "answer": "Yes, new path: 'libsoup/http1/soup-message-io-data.c'"}
{"question": "Has the file path of 'libsoup/soup-directory-input-stream.c' changed? What is the new path?", "answer": "Yes, new path: 'libsoup/server/http1/soup-server-message-io-http1.c'"}
{"question": "Has the file path of 'libsoup/soup-websocket.c' changed? What is the new path?", "answer": "Yes, new path: 'libsoup/websocket/soup-websocket.c'"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 138\n    FUNCTION_SIGNATURE: soup_auth_digest_get_qop (SoupAuthDigestQop qop)\n    HUNK_START_LINE_CONTENT: return g_string_free (out, FALSE);\n    FIRST_CHANGED_LINE_NUMBER: 140\n    FIRST_CHANGED_LINE_CONTENT: +static gboolean\n    HUNK_LINES:\n        return g_string_free (out, FALSE);\n    +static gboolean\n    +validate_params (SoupAuthDigest *auth_digest)\n    +{\n    +        SoupAuthDigestPrivate *priv = soup_auth_digest_get_instance_private (auth_digest);\n    +\n    +        if (priv->qop || priv->algorithm == SOUP_AUTH_DIGEST_ALGORITHM_MD5_SESS) {\n    +                if (!priv->nonce)\n    +                        return FALSE;\n    +        }\n    +\n    +        return TRUE;\n    +}\n    static gboolean\n    soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,\n                GHashTable *auth_params)", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 138\n    FUNCTION_SIGNATURE: soup_auth_digest_get_qop (SoupAuthDigestQop qop)\n    HUNK_START_LINE_CONTENT: return g_string_free (out, FALSE);\n    FIRST_CHANGED_LINE_NUMBER: 140\n    FIRST_CHANGED_LINE_CONTENT: +static gboolean\n    HUNK_LINES:\n        return g_string_free (out, FALSE);\n    +static gboolean\n    +validate_params (SoupAuthDigest *auth_digest)\n    +{\n    +        SoupAuthDigestPrivate *priv = soup_auth_digest_get_instance_private (auth_digest);\n    +\n    +        if (priv->qop || priv->algorithm == SOUP_AUTH_DIGEST_ALGORITHM_MD5_SESS) {\n    +                if (!priv->nonce)\n    +                        return FALSE;\n    +        }\n    +\n    +        return TRUE;\n    +}\n    static gboolean\n    soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,\n                GHashTable *auth_params)"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT: +        const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT: +        const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 305\n    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 305\n    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)"}
{"question": "What was the dependency for 'gmodule_dep' in the file 'meson.build' before the change?", "answer": "Old dependency: 'gmodule-2.0'"}
{"question": "What is the updated dependency for 'gmodule_dep' in the file 'meson.build' after the change?", "answer": "Updated dependency: 'gmodule-no-export-2.0'"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: meson.build\n    HUNK_START_LINE_NUMBER: 101\n    FUNCTION_SIGNATURE: add_project_arguments(common_flags, language : 'c')\n    HUNK_START_LINE_CONTENT: glib_required_version = '>= 2.70.0'\n    FIRST_CHANGED_LINE_NUMBER: 104\n    FIRST_CHANGED_LINE_CONTENT: -gmodule_dep = dependency('gmodule-2.0', version : glib_required_version,\n    HUNK_LINES:\n        glib_required_version = '>= 2.70.0'\n        glib_dep = dependency('glib-2.0', version : glib_required_version,\n                               fallback: ['glib', 'libglib_dep'])\n    -gmodule_dep = dependency('gmodule-2.0', version : glib_required_version,\n    +gmodule_dep = dependency('gmodule-no-export-2.0', version : glib_required_version,\n                               fallback: ['glib', 'libgmodule_dep'])\n        gobject_dep = dependency('gobject-2.0', version : glib_required_version,\n                               fallback: ['glib', 'libgobject_dep'])", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: meson.build\n    HUNK_START_LINE_NUMBER: 101\n    FUNCTION_SIGNATURE: add_project_arguments(common_flags, language : 'c')\n    HUNK_START_LINE_CONTENT: glib_required_version = '>= 2.70.0'\n    FIRST_CHANGED_LINE_NUMBER: 104\n    FIRST_CHANGED_LINE_CONTENT: -gmodule_dep = dependency('gmodule-2.0', version : glib_required_version,\n    HUNK_LINES:\n        glib_required_version = '>= 2.70.0'\n        glib_dep = dependency('glib-2.0', version : glib_required_version,\n                               fallback: ['glib', 'libglib_dep'])\n        gmodule_dep = dependency('gmodule-2.0', version : glib_required_version,\n                               fallback: ['glib', 'libgmodule_dep'])\n        gobject_dep = dependency('gobject-2.0', version : glib_required_version,\n                               fallback: ['glib', 'libgobject_dep'])"}
