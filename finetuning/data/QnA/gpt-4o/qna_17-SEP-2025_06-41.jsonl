{"question": "What change was made to the 'expires' field of the 'cookie' structure in the 'parse_one_cookie' function in 'libsoup/cookies/soup-cookie.c'?", "answer": "The 'expires' field is now cleared using 'g_clear_pointer' before being assigned a new value from 'parse_date'."}
{"question": "What modification was made to the 'parse_one_cookie' function in 'libsoup/cookies/soup-cookie.c' regarding memory management?", "answer": "Added 'g_clear_pointer' to safely unreference the 'expires' field before assigning a new value."}
{"question": "What is the new version number specified in the 'meson.build' file?", "answer": "Version updated to '3.6.1' from '3.6.0'."}
{"question": "What changes were made to the 'NEWS' file regarding the 'libsoup' version update?", "answer": "Added a section detailing changes from version 3.6.0 to 3.6.1, including bug fixes and improvements."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 669\n    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)\n    HUNK_START_LINE_CONTENT: look_for_tag:\n    FIRST_CHANGED_LINE_NUMBER: 671\n    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)\n    HUNK_LINES:\n        look_for_tag:\n    -    if (pos > resource_length)\n    +    if (pos >= resource_length)\n            goto text_html;\n\n        if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 669\n    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)\n    HUNK_START_LINE_CONTENT: look_for_tag:\n    FIRST_CHANGED_LINE_NUMBER: 671\n    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)\n    HUNK_LINES:\n        look_for_tag:\n    -    if (pos > resource_length)\n    +    if (pos >= resource_length)\n            goto text_html;\n\n        if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: tests/sniffing-test.c\n    HUNK_START_LINE_NUMBER: 512\n    FUNCTION_SIGNATURE: main (int argc, char **argv)\n    HUNK_START_LINE_CONTENT:         g_test_add_data_func (\"/sniffing/disabled\",\n    FIRST_CHANGED_LINE_NUMBER: 517\n    FIRST_CHANGED_LINE_CONTENT:     +    /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n    HUNK_LINES:\n        g_test_add_data_func (\"/sniffing/disabled\",\n                    \"/text_or_binary/home.gif\",\n                    test_disabled);\n\n    +    /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n    +    g_test_add_data_func (\"/sniffing/whitespace\",\n    +                      \"type/text_html/whitespace.html => text/html\",\n    +                      do_sniffing_test);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: tests/sniffing-test.c\n    HUNK_START_LINE_NUMBER: 512\n    FUNCTION_SIGNATURE: main (int argc, char **argv)\n    HUNK_START_LINE_CONTENT:         g_test_add_data_func (\"/sniffing/disabled\",\n    FIRST_CHANGED_LINE_NUMBER: 517\n    FIRST_CHANGED_LINE_CONTENT:     +    /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n    HUNK_LINES:\n        g_test_add_data_func (\"/sniffing/disabled\",\n                    \"/text_or_binary/home.gif\",\n                    test_disabled);\n\n    +    /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n    +    g_test_add_data_func (\"/sniffing/whitespace\",\n    +                      \"type/text_html/whitespace.html => text/html\",\n    +                      do_sniffing_test);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT:         const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT:         const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 303\n    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+            g_uri_unref (soup_uri);\n+            return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 303\n    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+            g_uri_unref (soup_uri);\n+            return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: tests/uri-parsing-test.c\n    HUNK_START_LINE_NUMBER: 141\n    FUNCTION_SIGNATURE: static struct {\n    HUNK_START_LINE_CONTENT:     { \"data:text/plain;base64,aGVsbG8=\", \"hello\", \"text/plain\" },\n    FIRST_CHANGED_LINE_NUMBER: 144\n    FIRST_CHANGED_LINE_CONTENT:     { \"data:.///\", NULL, NULL },\n    HUNK_LINES:\n        { \"data:text/plain;base64,aGVsbG8=\", \"hello\", \"text/plain\" },\n        { \"data:text/plain;base64,invalid=\", \"\", \"text/plain\" },\n        { \"data:,\", \"\", CONTENT_TYPE_DEFAULT },\n+        { \"data:.///\", NULL, NULL },\n+        { \"data:/.//\", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: tests/uri-parsing-test.c\n    HUNK_START_LINE_NUMBER: 141\n    FUNCTION_SIGNATURE: static struct {\n    HUNK_START_LINE_CONTENT:     { \"data:text/plain;base64,aGVsbG8=\", \"hello\", \"text/plain\" },\n    FIRST_CHANGED_LINE_NUMBER: 144\n    FIRST_CHANGED_LINE_CONTENT:     { \"data:.///\", NULL, NULL },\n    HUNK_LINES:\n        { \"data:text/plain;base64,aGVsbG8=\", \"hello\", \"text/plain\" },\n        { \"data:text/plain;base64,invalid=\", \"\", \"text/plain\" },\n        { \"data:,\", \"\", CONTENT_TYPE_DEFAULT },\n+        { \"data:.///\", NULL, NULL },\n+        { \"data:/.//\", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 524\n    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,\n    HUNK_START_LINE_CONTENT: guint index_pattern = 0;\n    FIRST_CHANGED_LINE_NUMBER: 527\n    FIRST_CHANGED_LINE_CONTENT: -            while ((index_stream < resource_length) &&\n    HUNK_LINES:\n        guint index_pattern = 0;\n        gboolean skip_row = FALSE;\n\n-        while ((index_stream < resource_length) &&\n+        while ((index_stream < resource_length - 1) &&\n            (index_pattern <= type_row->pattern_length)) {\n            /* Skip insignificant white space (\"WS\" in the spec) */\n            if (type_row->pattern[index_pattern] == ' ') {", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 524\n    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,\n    HUNK_START_LINE_CONTENT: guint index_pattern = 0;\n    FIRST_CHANGED_LINE_NUMBER: 527\n    FIRST_CHANGED_LINE_CONTENT: -            while ((index_stream < resource_length) &&\n    HUNK_LINES:\n        guint index_pattern = 0;\n        gboolean skip_row = FALSE;\n\n-        while ((index_stream < resource_length) &&\n+        while ((index_stream < resource_length - 1) &&\n            (index_pattern <= type_row->pattern_length)) {\n            /* Skip insignificant white space (\"WS\" in the spec) */\n            if (type_row->pattern[index_pattern] == ' ') {"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 72\n    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)\n    HUNK_START_LINE_CONTENT:     g_free (priv->cnonce);\n    FIRST_CHANGED_LINE_NUMBER: 75\n    FIRST_CHANGED_LINE_CONTENT: +        g_free (priv->opaque);\n    HUNK_LINES:\n        g_free (priv->nonce);\n        g_free (priv->domain);\n        g_free (priv->cnonce);\n+        g_free (priv->opaque);\n        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));\n        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 72\n    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)\n    HUNK_START_LINE_CONTENT:     g_free (priv->cnonce);\n    FIRST_CHANGED_LINE_NUMBER: 75\n    FIRST_CHANGED_LINE_CONTENT: +        g_free (priv->opaque);\n    HUNK_LINES:\n        g_free (priv->nonce);\n        g_free (priv->domain);\n        g_free (priv->cnonce);\n+        g_free (priv->opaque);\n        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));\n        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));"}
{"question": "What changes were made to the description of the support forum in the README file?", "answer": "The mailing list description was replaced with a Discourse support forum link."}
{"question": "Which lines in the README file were removed and replaced with new content?", "answer": "Lines describing the mailing list at gnome.org were removed and replaced with lines describing the Discourse support forum at discourse.gnome.org."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT:     const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT:     const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 305\n    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 305\n    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;"}
{"question": "Was a new translation file added for the Uzbek (Latin) language in the 'po' directory?", "answer": "Yes, the file 'po/uz.po' was added."}
{"question": "Was the 'LINGUAS' file updated to include a new language?", "answer": "Yes, the language 'uz' was added to the 'LINGUAS' file."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT: gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT: const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n    +        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);\n\n        if (content_type)\n                *content_type = NULL;\n\n    +        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n    +        path = g_uri_get_path (soup_uri);\n    +        if (path[0] == '/' && path[1] == '/') {\n    +                g_uri_unref (soup_uri);\n    +                return NULL;\n    +        }\n    +\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n                return NULL;", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT: gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT: const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n    +        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);\n\n        if (content_type)\n                *content_type = NULL;\n\n    +        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n    +        path = g_uri_get_path (soup_uri);\n    +        if (path[0] == '/' && path[1] == '/') {\n    +                g_uri_unref (soup_uri);\n    +                return NULL;\n    +        }\n    +\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n                return NULL;"}
{"question": "What is the updated condition in the 'if' statement at line 244 of the file 'libsoup/http1/soup-body-input-stream.c'?", "answer": "The condition was updated to check specific lengths and values of 'metabuf' for '\\r\\n' and '\\n'."}
{"question": "What was the previous condition in the 'if' statement at line 244 of the file 'libsoup/http1/soup-body-input-stream.c'?", "answer": "The condition was 'strncmp (metabuf, \"\\r\\n\", nread) || strncmp (metabuf, \"\\n\", nread)'."}
