{"question": "What changes were made to the handling of the 'expires' property of the 'cookie' variable in the 'parse_one_cookie' function within the 'libsoup/cookies/soup-cookie.c' file?", "answer": "The 'expires' property was cleared using 'g_clear_pointer' before setting it to the parsed date."}
{"question": "Was any code formatting or structure modified in the 'parse_one_cookie' function in the 'libsoup/cookies/soup-cookie.c' file?", "answer": "Yes, the line setting the 'expires' property was adjusted to use 'g_clear_pointer' for better memory management."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     pos = 3;
    FIRST_CHANGED_LINE_NUMBER: 671
    FIRST_CHANGED_LINE_CONTENT: -   if (pos > resource_length)
    HUNK_LINES:
        pos = 3;

look_for_tag:
-       if (pos > resource_length)
+       if (pos >= resource_length)
        goto text_html;

    if (skip_insignificant_space (resource, &pos, resource_length))
        goto text_html;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     pos = 3;
    FIRST_CHANGED_LINE_NUMBER: 671
    FIRST_CHANGED_LINE_CONTENT: -   if (pos > resource_length)
    HUNK_LINES:
        pos = 3;

look_for_tag:
-       if (pos > resource_length)
+       if (pos >= resource_length)
        goto text_html;

    if (skip_insignificant_space (resource, &pos, resource_length))
        goto text_html;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 291
    FIRST_CHANGED_LINE_CONTENT:     +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        uri_string = g_uri_to_string (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 291
    FIRST_CHANGED_LINE_CONTENT:     +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        uri_string = g_uri_to_string (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 302
    FIRST_CHANGED_LINE_CONTENT:     +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
                *content_type = NULL;

+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 302
    FIRST_CHANGED_LINE_CONTENT:     +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
                *content_type = NULL;

+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:     +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:     +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },"}
{"question": "What changes were made to the version number in the 'meson.build' file?", "answer": "Updated version from '3.6.0' to '3.6.1'."}
{"question": "What new fixes were added to the 'NEWS' file under the changes from version 3.6.0 to 3.6.1?", "answer": "Added fixes for 'soup_uri_copy', 'soup_uri_decode_data_uri', 'SoupContentSniffer', headers parsing, and websocket read loop."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:         pos = 3;
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)
    HUNK_LINES:
        pos = 3;

look_for_tag:
-       if (pos > resource_length)
+       if (pos >= resource_length)
            goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:         pos = 3;
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)
    HUNK_LINES:
        pos = 3;

look_for_tag:
-       if (pos > resource_length)
+       if (pos >= resource_length)
            goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: tests = [
    HUNK_START_LINE_CONTENT: {'name': 'session'},
    FIRST_CHANGED_LINE_NUMBER: 106
    FIRST_CHANGED_LINE_CONTENT:     +    {'name': 'sniffing',
    HUNK_LINES:
        {'name': 'session'},
        {'name': 'server-auth'},
        {'name': 'server'},
-       {'name': 'sniffing'},
+       {'name': 'sniffing',
+           'depends': [test_resources],
+       },
        {'name': 'ssl',
            'dependencies': [gnutls_dep],
            'depends': mock_pkcs11_module,", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: tests = [
    HUNK_START_LINE_CONTENT: {'name': 'session'},
    FIRST_CHANGED_LINE_NUMBER: 106
    FIRST_CHANGED_LINE_CONTENT:     +    {'name': 'sniffing',
    HUNK_LINES:
        {'name': 'session'},
        {'name': 'server-auth'},
        {'name': 'server'},
-       {'name': 'sniffing'},
+       {'name': 'sniffing',
+           'depends': [test_resources],
+       },
        {'name': 'ssl',
            'dependencies': [gnutls_dep],
            'depends': mock_pkcs11_module,"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/sniffing-test.c
    HUNK_START_LINE_NUMBER: 512
    FUNCTION_SIGNATURE: main (int argc, char **argv)
    HUNK_START_LINE_CONTENT:             "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",
    FIRST_CHANGED_LINE_NUMBER: 516
    FIRST_CHANGED_LINE_CONTENT:     +        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
    HUNK_LINES:
            "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",

+        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
+        g_test_add_data_func ("/sniffing/whitespace",
+                              "type/text_html/whitespace.html => text/html",
+                              do_sniffing_test);
+
        /* Test that disabling the sniffer works correctly */
        g_test_add_data_func ("/sniffing/disabled",
                    "/text_or_binary/home.gif",", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/sniffing-test.c
    HUNK_START_LINE_NUMBER: 512
    FUNCTION_SIGNATURE: main (int argc, char **argv)
    HUNK_START_LINE_CONTENT:             "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",
    FIRST_CHANGED_LINE_NUMBER: 516
    FIRST_CHANGED_LINE_CONTENT:     +        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
    HUNK_LINES:
            "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",

+        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
+        g_test_add_data_func ("/sniffing/whitespace",
+                              "type/text_html/whitespace.html => text/html",
+                              do_sniffing_test);
+
        /* Test that disabling the sniffer works correctly */
        g_test_add_data_func ("/sniffing/disabled",
                    "/text_or_binary/home.gif","}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 291
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 291
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 303
    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 303
    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:     SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1232
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        SOUP_ENCODING_NONE);

+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:     SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1232
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        SOUP_ENCODING_NONE);

+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

-       split = strstr (start, "\n\n");
+       split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

-       split = strstr (start, "\n\n");
+       split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

    +        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    +            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
            uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
            uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
            g_free (uri_string);
    +        if (uri == NULL)
    +            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
            soup_server_message_set_uri (msg_io->msg, uri);
            g_uri_unref (uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

    +        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    +            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
            uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
            uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
            g_free (uri_string);
    +        if (uri == NULL)
    +            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
            soup_server_message_set_uri (msg_io->msg, uri);
            g_uri_unref (uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1345
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        g_uri_unref (uri);
    }

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
 static gboolean
 unpause_message (SoupServerMessage *msg)
 {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1345
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        g_uri_unref (uri);
    }

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
 static gboolean
 unpause_message (SoupServerMessage *msg)
 {"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 641
    FUNCTION_SIGNATURE: skip_insignificant_space (const char *resource, int *pos, int resource_length)
    HUNK_START_LINE_CONTENT: (resource[*pos] == '\r')) {
    FIRST_CHANGED_LINE_NUMBER: 643
    FIRST_CHANGED_LINE_CONTENT: if (*pos >= resource_length)
    HUNK_LINES:
        (resource[*pos] == '\r')) {
        *pos = *pos + 1;

    -       if (*pos > resource_length)
    +       if (*pos >= resource_length)
            return TRUE;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 641
    FUNCTION_SIGNATURE: skip_insignificant_space (const char *resource, int *pos, int resource_length)
    HUNK_START_LINE_CONTENT: (resource[*pos] == '\r')) {
    FIRST_CHANGED_LINE_NUMBER: 643
    FIRST_CHANGED_LINE_CONTENT: if (*pos >= resource_length)
    HUNK_LINES:
        (resource[*pos] == '\r')) {
        *pos = *pos + 1;

    -       if (*pos > resource_length)
    +       if (*pos >= resource_length)
            return TRUE;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 704
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: do {
    FIRST_CHANGED_LINE_NUMBER: 706
    FIRST_CHANGED_LINE_CONTENT: if ((pos + 1) > resource_length)
    HUNK_LINES:
        do {
            pos++;

    -           if (pos > resource_length)
    +           if ((pos + 1) > resource_length)
                goto text_html;
            } while (resource[pos] != '>');", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 704
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: do {
    FIRST_CHANGED_LINE_NUMBER: 706
    FIRST_CHANGED_LINE_CONTENT: if ((pos + 1) > resource_length)
    HUNK_LINES:
        do {
            pos++;

    -           if (pos > resource_length)
    +           if ((pos + 1) > resource_length)
                goto text_html;
            } while (resource[pos] != '>');"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders *hdrs,
    HUNK_START_LINE_CONTENT:     char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT:         g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-            g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+            g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders *hdrs,
    HUNK_START_LINE_CONTENT:     char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT:         g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-            g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+            g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 1150
    FUNCTION_SIGNATURE: do_content_disposition_tests (void)
    HUNK_START_LINE_CONTENT:     soup_test_assert (FALSE, "empty filename decoding FAILED");
    FIRST_CHANGED_LINE_NUMBER: 1152
    FIRST_CHANGED_LINE_CONTENT:         g_free (disposition);
    HUNK_LINES:
        soup_test_assert (FALSE, "empty filename decoding FAILED");
        return;
    }
+        g_free (disposition);
    g_assert_false (g_hash_table_contains (params, "filename"));
    g_hash_table_destroy (params);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 1150
    FUNCTION_SIGNATURE: do_content_disposition_tests (void)
    HUNK_START_LINE_CONTENT:     soup_test_assert (FALSE, "empty filename decoding FAILED");
    FIRST_CHANGED_LINE_NUMBER: 1152
    FIRST_CHANGED_LINE_CONTENT:         g_free (disposition);
    HUNK_LINES:
        soup_test_assert (FALSE, "empty filename decoding FAILED");
        return;
    }
+        g_free (disposition);
    g_assert_false (g_hash_table_contains (params, "filename"));
    g_hash_table_destroy (params);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char          *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT: 	while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -	while ((*str == '\r' || *str == '\n') && len > 0) {
    +	while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char          *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT: 	while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -	while ((*str == '\r' || *str == '\n') && len > 0) {
    +	while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char          *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 374
    FIRST_CHANGED_LINE_CONTENT: 	while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
    -	while ((*str == '\r' || *str == '\n') && len > 0) {
    +	while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char          *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 374
    FIRST_CHANGED_LINE_CONTENT: 	while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
    -	while ((*str == '\r' || *str == '\n') && len > 0) {
    +	while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 10
    FIRST_CHANGED_LINE_CONTENT: 	static char unterminated_http_version[] = {
    HUNK_LINES:
        const char *name, *value;
    +
    +/* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
                'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 10
    FIRST_CHANGED_LINE_CONTENT: 	static char unterminated_http_version[] = {
    HUNK_LINES:
        const char *name, *value;
    +
    +/* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
                'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 387
    FUNCTION_SIGNATURE: static struct RequestTest {
    HUNK_START_LINE_CONTENT:         { { NULL } }
    FIRST_CHANGED_LINE_NUMBER: 461
    FIRST_CHANGED_LINE_CONTENT: 		{ "Only newlines", NULL,
    HUNK_LINES:
            { { NULL } }
            },
        
    -        /* This couldn't be a C string as going one byte over would have been safe. */
            { "Long HTTP version terminating at missing minor version", "https://gitlab.gnome.org/GNOME/libsoup/-/issues/404",
            unterminated_http_version, sizeof (unterminated_http_version),
            SOUP_STATUS_BAD_REQUEST,
    
    +		{ "Only newlines", NULL,
    +		  only_newlines, sizeof (only_newlines),
    +		  SOUP_STATUS_BAD_REQUEST,
    +		   NULL, NULL, -1,
    +		  { { NULL } }
            }
        };
        static const int num_reqtests = G_N_ELEMENTS (reqtests);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 387
    FUNCTION_SIGNATURE: static struct RequestTest {
    HUNK_START_LINE_CONTENT:         { { NULL } }
    FIRST_CHANGED_LINE_NUMBER: 461
    FIRST_CHANGED_LINE_CONTENT: 		{ "Only newlines", NULL,
    HUNK_LINES:
            { { NULL } }
            },
        
    -        /* This couldn't be a C string as going one byte over would have been safe. */
            { "Long HTTP version terminating at missing minor version", "https://gitlab.gnome.org/GNOME/libsoup/-/issues/404",
            unterminated_http_version, sizeof (unterminated_http_version),
            SOUP_STATUS_BAD_REQUEST,
    
    +		{ "Only newlines", NULL,
    +		  only_newlines, sizeof (only_newlines),
    +		  SOUP_STATUS_BAD_REQUEST,
    +		   NULL, NULL, -1,
    +		  { { NULL } }
            }
        };
        static const int num_reqtests = G_N_ELEMENTS (reqtests);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: 	box_size = *((guint32*)resource);
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
-       guint32 box_size = *((guint32*)resource);
+       guint32 box_size;
        guint i;
    
+           if (resource_length < sizeof (guint32))
+                   return FALSE;
    
+       box_size = *((guint32*)resource);
    
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: 	box_size = *((guint32*)resource);
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
-       guint32 box_size = *((guint32*)resource);
+       guint32 box_size;
        guint i;
    
+           if (resource_length < sizeof (guint32))
+                   return FALSE;
    
+       box_size = *((guint32*)resource);
    
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:     if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:     if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop="auth"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
    int
    main (int argc, char **argv)
    {
    @@ -1899,6 +1948,7 @@ main (int argc, char **argv)
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);

        ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop="auth"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
    int
    main (int argc, char **argv)
    {
    @@ -1899,6 +1948,7 @@ main (int argc, char **argv)
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);

        ret = g_test_run ();"}
{"question": "The README file mentions a mailing list for libsoup-related discussions. What was the new platform for discussions added in the recent commit?", "answer": "The mailing list reference was replaced with a Discourse support forum at https://discourse.gnome.org/tag/libsoup."}
{"question": "In the README file, what URL was removed that was previously used for subscribing or reading archives?", "answer": "The URL http://mail.gnome.org/mailman/listinfo/libsoup-list was removed."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
            *content_type = NULL;
    FIRST_CHANGED_LINE_NUMBER: 304
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
            *content_type = NULL;
    FIRST_CHANGED_LINE_NUMBER: 304
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:         SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1232
    FIRST_CHANGED_LINE_CONTENT:         +        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        SOUP_ENCODING_NONE);

+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:         SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1232
    FIRST_CHANGED_LINE_CONTENT:         +        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        SOUP_ENCODING_NONE);

+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: 
    FIRST_CHANGED_LINE_NUMBER: 4
    FIRST_CHANGED_LINE_CONTENT:     +#include "soup-uri-utils-private.h"
    HUNK_LINES:
        
#include "test-utils.h"
+#include "soup-uri-utils-private.h"

static const char *base_uri;
static GMainLoop *loop;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: 
    FIRST_CHANGED_LINE_NUMBER: 4
    FIRST_CHANGED_LINE_CONTENT:     +#include "soup-uri-utils-private.h"
    HUNK_LINES:
        
#include "test-utils.h"
+#include "soup-uri-utils-private.h"

static const char *base_uri;
static GMainLoop *loop;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1918
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}

+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}

+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1918
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}

+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}

+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT:         return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT:         split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;
    -       split = strstr (start, "\n\n");
    +       split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT:         return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT:         split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;
    -       split = strstr (start, "\n\n");
    +       split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT:     loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 477
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }

    +static void
    +test_multipart_bounds_good (void)
    +{
    +    #define TEXT "line1\nline2"
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers, *set_headers = NULL;
    +    GBytes *bytes, *set_bytes = NULL;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +    gboolean success;
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +
    +    g_assert_nonnull (multipart);
    +    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
    +    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
    +    g_assert_true (success);
    +    g_assert_nonnull (set_headers);
    +    g_assert_nonnull (set_bytes);
    +    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
    +    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
    +    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +
    +    soup_multipart_free (multipart);
    +
    +    #undef TEXT
    +}
    +
    +static void
    +test_multipart_bounds_bad (void)
    +{
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers;
    +    GBytes *bytes;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    /* it did read out of raw_data/bytes bounds */
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_null (multipart);
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +}", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT:     loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 477
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }

    +static void
    +test_multipart_bounds_good (void)
    +{
    +    #define TEXT "line1\nline2"
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers, *set_headers = NULL;
    +    GBytes *bytes, *set_bytes = NULL;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +    gboolean success;
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +
    +    g_assert_nonnull (multipart);
    +    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
    +    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
    +    g_assert_true (success);
    +    g_assert_nonnull (set_headers);
    +    g_assert_nonnull (set_bytes);
    +    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
    +    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
    +    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +
    +    soup_multipart_free (multipart);
    +
    +    #undef TEXT
    +}
    +
    +static void
    +test_multipart_bounds_bad (void)
    +{
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers;
    +    GBytes *bytes;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    /* it did read out of raw_data/bytes bounds */
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_null (multipart);
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +}"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char          *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT: 	while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -	while ((*str == '\r' || *str == '\n') && len > 0) {
    +	while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char          *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT: 	while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -	while ((*str == '\r' || *str == '\n') && len > 0) {
    +	while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:     +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

+        if (!soup_auth_get_realm (auth))
+                return FALSE;
+
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:     +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

+        if (!soup_auth_get_realm (auth))
+                return FALSE;
+
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1868
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+on_request_read_for_missing_realm (SoupServer        *server,
+                                   SoupServerMessage *msg,
+                                   gpointer           user_data)
+{
+        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
+        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
+}
+
+static void
+do_missing_realm_test (void)
+{
+        SoupSession *session;
+        SoupMessage *msg;
+        SoupServer *server;
+        SoupAuthDomain *digest_auth_domain;
+        gint status;
+        GUri *uri;
+
+        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+        soup_server_add_handler (server, NULL,
+                                 server_callback, NULL, NULL);
+        uri = soup_test_server_get_uri (server, "http", NULL);
+
+        digest_auth_domain = soup_auth_domain_digest_new (
+                "realm", "auth-test",
+                "auth-callback", server_digest_auth_callback,
+                NULL);
+        soup_auth_domain_add_path (digest_auth_domain, "/");
+        soup_server_add_auth_domain (server, digest_auth_domain);
+        g_object_unref (digest_auth_domain);
+
+        g_signal_connect (server, "request-read",
+                          G_CALLBACK (on_request_read_for_missing_realm),
+                          NULL);
+
+        session = soup_test_session_new (NULL);
+        msg = soup_message_new_from_uri ("GET", uri);
+        g_signal_connect (msg, "authenticate",
+                          G_CALLBACK (on_digest_authenticate),
+                          NULL);
+
+        status = soup_test_session_send_message (session, msg);
+
+        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+        g_uri_unref (uri);
+        soup_test_server_quit_unref (server);
+}
+
    int
    main (int argc, char **argv)
    {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1868
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+on_request_read_for_missing_realm (SoupServer        *server,
+                                   SoupServerMessage *msg,
+                                   gpointer           user_data)
+{
+        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
+        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
+}
+
+static void
+do_missing_realm_test (void)
+{
+        SoupSession *session;
+        SoupMessage *msg;
+        SoupServer *server;
+        SoupAuthDomain *digest_auth_domain;
+        gint status;
+        GUri *uri;
+
+        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+        soup_server_add_handler (server, NULL,
+                                 server_callback, NULL, NULL);
+        uri = soup_test_server_get_uri (server, "http", NULL);
+
+        digest_auth_domain = soup_auth_domain_digest_new (
+                "realm", "auth-test",
+                "auth-callback", server_digest_auth_callback,
+                NULL);
+        soup_auth_domain_add_path (digest_auth_domain, "/");
+        soup_server_add_auth_domain (server, digest_auth_domain);
+        g_object_unref (digest_auth_domain);
+
+        g_signal_connect (server, "request-read",
+                          G_CALLBACK (on_request_read_for_missing_realm),
+                          NULL);
+
+        session = soup_test_session_new (NULL);
+        msg = soup_message_new_from_uri ("GET", uri);
+        g_signal_connect (msg, "authenticate",
+                          G_CALLBACK (on_digest_authenticate),
+                          NULL);
+
+        status = soup_test_session_send_message (session, msg);
+
+        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+        g_uri_unref (uri);
+        soup_test_server_quit_unref (server);
+}
+
    int
    main (int argc, char **argv)
    {"}
{"question": "Was a new language added to the translation list in the file 'po/LINGUAS' and what was it?", "answer": "Yes, the language 'uz' (Uzbek Latin) was added."}
{"question": "Was a new translation file added to the 'po' directory and what is its name?", "answer": "Yes, the file 'po/uz.po' was added."}
{"question": "ORIGINAL_HUNK_DATA:
FILE_PATH: libsoup/soup-multipart.c
HUNK_START_LINE_NUMBER: 204
FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
HUNK_START_LINE_CONTENT: part_body = g_bytes_new_from_bytes (body, // FIXME
FIRST_CHANGED_LINE_NUMBER: 206
FIRST_CHANGED_LINE_CONTENT: end - 2 >= split ? end - 2 - split : 0);
HUNK_LINES:
part_body = g_bytes_new_from_bytes (body, // FIXME
                        split - body_data,
+                       end - 2 >= split ? end - 2 - split : 0);
g_ptr_array_add (multipart->bodies, part_body);

start = end;", "answer": "BACKPORTED_HUNK_DATA:
FILE_PATH: libsoup/soup-multipart.c
HUNK_START_LINE_NUMBER: 204
FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
HUNK_START_LINE_CONTENT: part_body = g_bytes_new_from_bytes (body, // FIXME
FIRST_CHANGED_LINE_NUMBER: 206
FIRST_CHANGED_LINE_CONTENT: end - 2 >= split ? end - 2 - split : 0);
HUNK_LINES:
part_body = g_bytes_new_from_bytes (body, // FIXME
                        split - body_data,
+                       end - 2 >= split ? end - 2 - split : 0);
g_ptr_array_add (multipart->bodies, part_body);

start = end;"}
{"question": "ORIGINAL_HUNK_DATA:
FILE_PATH: tests/multipart-test.c
HUNK_START_LINE_NUMBER: 527
FUNCTION_SIGNATURE: test_multipart_bounds_bad (void)
HUNK_START_LINE_CONTENT: g_bytes_unref (bytes);
FIRST_CHANGED_LINE_NUMBER: 529
FIRST_CHANGED_LINE_CONTENT: static void
test_multipart_too_large (void)
{
const char *raw_body =
"-------------------
";
HUNK_LINES:
g_bytes_unref (bytes);

+static void
+test_multipart_too_large (void)
+{
+   const char *raw_body =
+       "-------------------
";
+   GBytes *body;
+   GHashTable *params;
+   SoupMessageHeaders *headers;
+   SoupMultipart *multipart;
+
+   params = g_hash_table_new (g_str_hash, g_str_equal);
+   g_hash_table_insert (params, (gpointer) "boundary", (gpointer) "-----------------");
+   headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+   soup_message_headers_set_content_type (headers, "multipart/form-data", params);
+   g_hash_table_unref (params);
+
+   body = g_bytes_new_static (raw_body, strlen (raw_body));
+   multipart = soup_multipart_new_from_message (headers, body);
+   soup_message_headers_unref (headers);
+   g_bytes_unref (body);
+
+   g_assert_nonnull (multipart);
+   g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
+   g_assert_true (soup_multipart_get_part (multipart, 0, &headers, &body));
+   g_assert_cmpint (g_bytes_get_size (body), ==, 0);
+   soup_multipart_free (multipart);
+}
+
int
main (int argc, char **argv)
{
    g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
+   g_test_add_func ("/multipart/too-large", test_multipart_too_large);

    ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
FILE_PATH: tests/multipart-test.c
HUNK_START_LINE_NUMBER: 527
FUNCTION_SIGNATURE: test_multipart_bounds_bad (void)
HUNK_START_LINE_CONTENT: g_bytes_unref (bytes);
FIRST_CHANGED_LINE_NUMBER: 529
FIRST_CHANGED_LINE_CONTENT: static void
test_multipart_too_large (void)
{
const char *raw_body =
"-------------------
";
HUNK_LINES:
g_bytes_unref (bytes);

+static void
+test_multipart_too_large (void)
+{
+   const char *raw_body =
+       "-------------------
";
+   GBytes *body;
+   GHashTable *params;
+   SoupMessageHeaders *headers;
+   SoupMultipart *multipart;
+
+   params = g_hash_table_new (g_str_hash, g_str_equal);
+   g_hash_table_insert (params, (gpointer) "boundary", (gpointer) "-----------------");
+   headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+   soup_message_headers_set_content_type (headers, "multipart/form-data", params);
+   g_hash_table_unref (params);
+
+   body = g_bytes_new_static (raw_body, strlen (raw_body));
+   multipart = soup_multipart_new_from_message (headers, body);
+   soup_message_headers_unref (headers);
+   g_bytes_unref (body);
+
+   g_assert_nonnull (multipart);
+   g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
+   g_assert_true (soup_multipart_get_part (multipart, 0, &headers, &body));
+   g_assert_cmpint (g_bytes_get_size (body), ==, 0);
+   soup_multipart_free (multipart);
+}
+
int
main (int argc, char **argv)
{
    g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
+   g_test_add_func ("/multipart/too-large", test_multipart_too_large);

    ret = g_test_run ();"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT: SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1236
    FIRST_CHANGED_LINE_CONTENT: +        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        SOUP_ENCODING_NONE);
+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT: SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1236
    FIRST_CHANGED_LINE_CONTENT: +        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        SOUP_ENCODING_NONE);
+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: #include "test-utils.h"
    FIRST_CHANGED_LINE_NUMBER: 3
    FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
    HUNK_LINES:
    #include "test-utils.h"
+#include "soup-uri-utils-private.h"

static const char *base_uri;
static GMainLoop *loop;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: #include "test-utils.h"
    FIRST_CHANGED_LINE_NUMBER: 3
    FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
    HUNK_LINES:
    #include "test-utils.h"
+#include "soup-uri-utils-private.h"

static const char *base_uri;
static GMainLoop *loop;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT: soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
    soup_test_server_quit_unref (server);

+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}
+
+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}
+
+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT: soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
    soup_test_server_quit_unref (server);

+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}
+
+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}
+
+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 177
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n");
    HUNK_LINES:
        return NULL;
    
-       split = strstr (start, "\n");
+       split = g_strstr_len (start, body_end - start, "\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    File_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 177
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n");
    HUNK_LINES:
        return NULL;
    
-       split = strstr (start, "\n");
+       split = g_strstr_len (start, body_end - start, "\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 475
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }
    
+static void
+test_multipart_bounds_good (void)
+{
+    #define TEXT "line1\nline2"
+    SoupMultipart *multipart;
+    SoupMessageHeaders *headers, *set_headers = NULL;
+    GBytes *bytes, *set_bytes = NULL;
+    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
+    gboolean success;
+
+    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+    bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+    multipart = soup_multipart_new_from_message (headers, bytes);
+
+    g_assert_nonnull (multipart);
+    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
+    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
+    g_assert_true (success);
+    g_assert_nonnull (set_headers);
+    g_assert_nonnull (set_bytes);
+    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
+    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
+    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
+
+    soup_message_headers_unref (headers);
+    g_bytes_unref (bytes);
+
+    soup_multipart_free (multipart);
+
+    #undef TEXT
+}
+
+static void
+test_multipart_bounds_bad (void)
+{
+    SoupMultipart *multipart;
+    SoupMessageHeaders *headers;
+    GBytes *bytes;
+    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
+
+    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+    bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+    /* it did read out of raw_data/bytes bounds */
+    multipart = soup_multipart_new_from_message (headers, bytes);
+    g_assert_null (multipart);
+
+    soup_message_headers_unref (headers);
+    g_bytes_unref (bytes);
+}
+
+int
+main (int argc, char **argv)
+{
+    g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
+    g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
+    g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
+    g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
+    g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
+
+    ret = g_test_run ();
+", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 475
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }
    
+static void
+test_multipart_bounds_good (void)
+{
+    #define TEXT "line1\nline2"
+    SoupMultipart *multipart;
+    SoupMessageHeaders *headers, *set_headers = NULL;
+    GBytes *bytes, *set_bytes = NULL;
+    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
+    gboolean success;
+
+    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+    bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+    multipart = soup_multipart_new_from_message (headers, bytes);
+
+    g_assert_nonnull (multipart);
+    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
+    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
+    g_assert_true (success);
+    g_assert_nonnull (set_headers);
+    g_assert_nonnull (set_bytes);
+    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
+    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
+    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
+
+    soup_message_headers_unref (headers);
+    g_bytes_unref (bytes);
+
+    soup_multipart_free (multipart);
+
+    #undef TEXT
+}
+
+static void
+test_multipart_bounds_bad (void)
+{
+    SoupMultipart *multipart;
+    SoupMessageHeaders *headers;
+    GBytes *bytes;
+    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
+
+    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+    bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+    /* it did read out of raw_data/bytes bounds */
+    multipart = soup_multipart_new_from_message (headers, bytes);
+    g_assert_null (multipart);
+
+    soup_message_headers_unref (headers);
+    g_bytes_unref (bytes);
+}
+
+int
+main (int argc, char **argv)
+{
+    g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
+    g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
+    g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
+    g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
+    g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
+
+    ret = g_test_run ();
+"}
{"question": "What is the change in the condition within the function soup-body-input-stream at line 244 in the file libsoup/http1/soup-body-input-stream.c?", "answer": "Condition modified to check specific nread values with metabuf comparison."}
{"question": "Which state is updated in the soup-body-input-stream function in libsoup/http1/soup-body-input-stream.c due to the logic change?", "answer": "State SOUP_BODY_INPUT_STREAM_STATE_DONE updated when new conditions are met."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)
    HUNK_LINES:
        look_for_tag:
-    if (pos > resource_length)
+    if (pos >= resource_length)
        goto text_html;

    if (skip_insignificant_space (resource, &pos, resource_length))
        goto text_html;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)
    HUNK_LINES:
        look_for_tag:
-    if (pos > resource_length)
+    if (pos >= resource_length)
        goto text_html;

    if (skip_insignificant_space (resource, &pos, resource_length))
        goto text_html;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;
        g_return_val_if_fail (uri != NULL, NULL);

        soup_uri = g_uri_parse (uri, G_URI_FLAGS_NONE, &error);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;
        g_return_val_if_fail (uri != NULL, NULL);

        soup_uri = g_uri_parse (uri, G_URI_FLAGS_NONE, &error);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
            *content_type = NULL;
    FIRST_CHANGED_LINE_NUMBER: 303
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
            *content_type = NULL;
    FIRST_CHANGED_LINE_NUMBER: 303
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT:     return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT:         split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

    		split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT:     return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT:         split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

    		split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT:     loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 477
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }

    +static void
    +test_multipart_bounds_good (void)
    +{
    +    #define TEXT "line1\nline2"
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers, *set_headers = NULL;
    +    GBytes *bytes, *set_bytes = NULL;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +    gboolean success;
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +
    +    g_assert_nonnull (multipart);
    +    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
    +    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
    +    g_assert_true (success);
    +    g_assert_nonnull (set_headers);
    +    g_assert_nonnull (set_bytes);
    +    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
    +    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
    +    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +
    +    soup_multipart_free (multipart);
    +
    +    #undef TEXT
    +}
    +
    +static void
    +test_multipart_bounds_bad (void)
    +{
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers;
    +    GBytes *bytes;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    /* it did read out of raw_data/bytes bounds */
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_null (multipart);
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +}
    +
    int
    main (int argc, char **argv)
    {
    +    g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
    +    g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
    +    g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
    +    g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
    +    g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
    
        ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT:     loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 477
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }

    +static void
    +test_multipart_bounds_good (void)
    +{
    +    #define TEXT "line1\nline2"
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers, *set_headers = NULL;
    +    GBytes *bytes, *set_bytes = NULL;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +    gboolean success;
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +
    +    g_assert_nonnull (multipart);
    +    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
    +    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
    +    g_assert_true (success);
    +    g_assert_nonnull (set_headers);
    +    g_assert_nonnull (set_bytes);
    +    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
    +    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
    +    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +
    +    soup_multipart_free (multipart);
    +
    +    #undef TEXT
    +}
    +
    +static void
    +test_multipart_bounds_bad (void)
    +{
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers;
    +    GBytes *bytes;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +
    +    /* it did read out of raw_data/bytes bounds */
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_null (multipart);
    +
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +}
    +
    int
    main (int argc, char **argv)
    {
    +    g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
    +    g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
    +    g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
    +    g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
    +    g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
    
        ret = g_test_run ();"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT: char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT: char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");"}
{"question": "What is the new path for the file 'libsoup/soup-cache-input-stream.c' after the update?", "answer": "New path: libsoup/cache/soup-cache-input-stream.c"}
{"question": "What is the new path for the file 'libsoup/soup-converter-wrapper.c' after the update?", "answer": "New path: libsoup/content-decoder/soup-converter-wrapper.c"}
{"question": "What line was added to the Greek translation file to update the last translator information?", "answer": "Added line: 'Last-Translator: Giannis Antypas <gianni.antypas@gmail.com>'"}
{"question": "What line was updated in the Greek translation file to reflect the POT creation date?", "answer": "Updated line: 'POT-Creation-Date: 2023-01-25 21:07+0000'"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        if (content_type)
                *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }

        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)
                return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        if (content_type)
                *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }

        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)
                return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:             gboolean skip_row = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 527
    FIRST_CHANGED_LINE_CONTENT:             while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        gboolean skip_row = FALSE;

-        while ((index_stream < resource_length) &&
+        while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:             gboolean skip_row = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 527
    FIRST_CHANGED_LINE_CONTENT:             while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        gboolean skip_row = FALSE;

-        while ((index_stream < resource_length) &&
+        while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:         }
    FIRST_CHANGED_LINE_NUMBER: 1232
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        }

        /* Strip all credentials on cross-origin redirect. */
        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
                soup_message_set_auth (msg, NULL);
        }

        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:         }
    FIRST_CHANGED_LINE_NUMBER: 1232
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        }

        /* Strip all credentials on cross-origin redirect. */
        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
                soup_message_set_auth (msg, NULL);
        }

        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: 
    FIRST_CHANGED_LINE_NUMBER: 4
    FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
    HUNK_LINES:
    
    #include "test-utils.h"
    +#include "soup-uri-utils-private.h"

    static const char *base_uri;
    static GMainLoop *loop;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: 
    FIRST_CHANGED_LINE_NUMBER: 4
    FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
    HUNK_LINES:
    
    #include "test-utils.h"
    +#include "soup-uri-utils-private.h"

    static const char *base_uri;
    static GMainLoop *loop;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    +static void
    +redirect_server_callback (SoupServer        *server,
    +                          SoupServerMessage *msg,
    +                          const char        *path,
    +                          GHashTable        *query,
    +                          gpointer           user_data)
    +{
    +    static gboolean redirected = FALSE;
    +
    +    if (!redirected) {
    +        char *redirect_uri = g_uri_to_string (user_data);
    +        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
    +        g_free (redirect_uri);
    +        redirected = TRUE;
    +        return;
    +    }
    +
    +    g_assert_not_reached ();
    +}", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    +static void
    +redirect_server_callback (SoupServer        *server,
    +                          SoupServerMessage *msg,
    +                          const char        *path,
    +                          GHashTable        *query,
    +                          gpointer           user_data)
    +{
    +    static gboolean redirected = FALSE;
    +
    +    if (!redirected) {
    +        char *redirect_uri = g_uri_to_string (user_data);
    +        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
    +        g_free (redirect_uri);
    +        redirected = TRUE;
    +        return;
    +    }
    +
    +    g_assert_not_reached ();
    +}"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

        split = strstr (start, "\n\n");
    +   split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 176
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

        split = strstr (start, "\n\n");
    +   split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 475
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    +   static void
    +   test_multipart_bounds_good (void)
    +   {
    +   #define TEXT "line1\nline2"
    +   ...
    +   test_multipart_bounds_bad (void)
    +   {
    +   ...
    +   g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
    +   g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 475
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    +   static void
    +   test_multipart_bounds_good (void)
    +   {
    +   #define TEXT "line1\nline2"
    +   ...
    +   test_multipart_bounds_bad (void)
    +   {
    +   ...
    +   g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
    +   g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 774
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+       if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+           return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+       if (uri == NULL)
+           return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 774
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+       if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+           return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+       if (uri == NULL)
+           return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT:                     char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT:                     char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT:         while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -       while ((*str == '\r' || *str == '\n') && len > 0) {
    +       while (len > 0 && (*str == '\r' || *str == '\n')) {
                str++;
                len--;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT:         while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -       while ((*str == '\r' || *str == '\n') && len > 0) {
    +       while (len > 0 && (*str == '\r' || *str == '\n')) {
                str++;
                len--;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 374
    FIRST_CHANGED_LINE_CONTENT:         while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
        */
    -       while ((*str == '\r' || *str == '\n') && len > 0) {
    +       while (len > 0 && (*str == '\r' || *str == '\n')) {
                str++;
                len--;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 374
    FIRST_CHANGED_LINE_CONTENT:         while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
        */
    -       while ((*str == '\r' || *str == '\n') && len > 0) {
    +       while (len > 0 && (*str == '\r' || *str == '\n')) {
                str++;
                len--;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 9
    FIRST_CHANGED_LINE_CONTENT:     +/* These are not C strings to ensure going one byte over is not safe. */
    HUNK_LINES:
        const char *name, *value;
        }
    +/* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
        'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 9
    FIRST_CHANGED_LINE_CONTENT:     +/* These are not C strings to ensure going one byte over is not safe. */
    HUNK_LINES:
        const char *name, *value;
        }
    +/* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
        'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};"}
{"question": "The README file mentions a reference to the libsoup To Do list in the old version. What is the change to this reference?", "answer": "The reference to the libsoup To Do list was removed."}
{"question": "The README file contains a URL to the libsoup wiki. What change was made to the description of this URL?", "answer": "The description was updated to remove the mention of the To Do list."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT:                         char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT:                         char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 149
    FIRST_CHANGED_LINE_CONTENT:     +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 149
    FIRST_CHANGED_LINE_CONTENT:     +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
        int
        main (int argc, char **argv)
        {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
        int
        main (int argc, char **argv)
        {"}
{"question": "The dependency 'gmodule-2.0' is specified in 'meson.build'. What is the new dependency after the change?", "answer": "Dependency changed to 'gmodule-no-export-2.0'."}
{"question": "What modification was made to the line involving 'gmodule_dep' in the 'meson.build' file?", "answer": "The dependency was updated to 'gmodule-no-export-2.0'."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 670
    FIRST_CHANGED_LINE_CONTENT:     -    if (pos > resource_length)
    HUNK_LINES:
        look_for_tag:
    -    if (pos > resource_length)
    +    if (pos >= resource_length)
            goto text_html;
        if (skip_insignificant_space (resource, &pos, resource_length))
            goto text_html;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 670
    FIRST_CHANGED_LINE_CONTENT:     -    if (pos > resource_length)
    HUNK_LINES:
        look_for_tag:
    -    if (pos > resource_length)
    +    if (pos >= resource_length)
            goto text_html;
        if (skip_insignificant_space (resource, &pos, resource_length))
            goto text_html;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: tests = [
    HUNK_START_LINE_CONTENT:     {'name': 'server'},
    FIRST_CHANGED_LINE_NUMBER: 106
    FIRST_CHANGED_LINE_CONTENT:     -  {'name': 'sniffing'},
    HUNK_LINES:
        {'name': 'server'},
    -  {'name': 'sniffing'},
    +  {'name': 'sniffing',
    +    'depends': [test_resources],
    +  },
        {'name': 'ssl',
            'dependencies': [gnutls_dep],
            'depends': mock_pkcs11_module,", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: tests = [
    HUNK_START_LINE_CONTENT:     {'name': 'server'},
    FIRST_CHANGED_LINE_NUMBER: 106
    FIRST_CHANGED_LINE_CONTENT:     -  {'name': 'sniffing'},
    HUNK_LINES:
        {'name': 'server'},
    -  {'name': 'sniffing'},
    +  {'name': 'sniffing',
    +    'depends': [test_resources],
    +  },
        {'name': 'ssl',
            'dependencies': [gnutls_dep],
            'depends': mock_pkcs11_module,"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 305
    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 305
    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:         guint index_pattern = 0;
    FIRST_CHANGED_LINE_NUMBER: 526
    FIRST_CHANGED_LINE_CONTENT: +           while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        guint index_pattern = 0;
        gboolean skip_row = FALSE;

-       while ((index_stream < resource_length) &&
+       while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:         guint index_pattern = 0;
    FIRST_CHANGED_LINE_NUMBER: 526
    FIRST_CHANGED_LINE_CONTENT: +           while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        guint index_pattern = 0;
        gboolean skip_row = FALSE;

-       while ((index_stream < resource_length) &&
+       while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 177
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;
    - split = strstr (start, "\n\n");
    + split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 177
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;
    - split = strstr (start, "\n\n");
    + split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 477
    FIRST_CHANGED_LINE_CONTENT: test_multipart_bounds_good (void)
    HUNK_LINES:
        loop = NULL;
    + static void
    + test_multipart_bounds_good (void)
    + {
    +    #define TEXT "line1\nline2"
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers, *set_headers = NULL;
    +    GBytes *bytes, *set_bytes = NULL;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +    gboolean success;
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_nonnull (multipart);
    +    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
    +    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
    +    g_assert_true (success);
    +    g_assert_nonnull (set_headers);
    +    g_assert_nonnull (set_bytes);
    +    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
    +    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
    +    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +    soup_multipart_free (multipart);
    +    #undef TEXT
    + }
    + static void
    + test_multipart_bounds_bad (void)
    + {
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers;
    +    GBytes *bytes;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +    /* it did read out of raw_data/bytes bounds */
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_null (multipart);
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    + }
        int
        main (int argc, char **argv)
        {
    @@ -498,6 +554,8 @@ main (int argc, char **argv)
        g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
        g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
        g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
    +    g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
    +    g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
        ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 477
    FIRST_CHANGED_LINE_CONTENT: test_multipart_bounds_good (void)
    HUNK_LINES:
        loop = NULL;
    + static void
    + test_multipart_bounds_good (void)
    + {
    +    #define TEXT "line1\nline2"
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers, *set_headers = NULL;
    +    GBytes *bytes, *set_bytes = NULL;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +    gboolean success;
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_nonnull (multipart);
    +    g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
    +    success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
    +    g_assert_true (success);
    +    g_assert_nonnull (set_headers);
    +    g_assert_nonnull (set_bytes);
    +    g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
    +    g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
    +    g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    +    soup_multipart_free (multipart);
    +    #undef TEXT
    + }
    + static void
    + test_multipart_bounds_bad (void)
    + {
    +    SoupMultipart *multipart;
    +    SoupMessageHeaders *headers;
    +    GBytes *bytes;
    +    const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +    headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
    +    soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
    +    bytes = g_bytes_new (raw_data, strlen (raw_data));
    +    /* it did read out of raw_data/bytes bounds */
    +    multipart = soup_multipart_new_from_message (headers, bytes);
    +    g_assert_null (multipart);
    +    soup_message_headers_unref (headers);
    +    g_bytes_unref (bytes);
    + }
        int
        main (int argc, char **argv)
        {
    @@ -498,6 +554,8 @@ main (int argc, char **argv)
        g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
        g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
        g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
    +    g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
    +    g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
        ret = g_test_run ();"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT: char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
            /* filename with no value isn't valid. */
            g_hash_table_remove (*params, "filename");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT: char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+                                g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
            /* filename with no value isn't valid. */
            g_hash_table_remove (*params, "filename");"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: +       guint32 box_size;
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
-       guint32 box_size = *((guint32*)resource);
+       guint32 box_size;
        guint i;

+        if (resource_length < sizeof (guint32))
+                return FALSE;
+
+       box_size = *((guint32*)resource);
+
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: +       guint32 box_size;
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
-       guint32 box_size = *((guint32*)resource);
+       guint32 box_size;
        guint i;

+        if (resource_length < sizeof (guint32))
+                return FALSE;
+
+       box_size = *((guint32*)resource);
+
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |"}
{"question": "The function 'soup_auth_digest_finalize' in file 'libsoup/auth/soup-auth-digest.c' had a new operation added. What was the operation?", "answer": "Added 'g_free (priv->opaque);' to the function 'soup_auth_digest_finalize'."}
{"question": "The function 'soup_auth_digest_finalize' in the file 'libsoup/auth/soup-auth-digest.c' had changes in the commit. Was any line added in the function, and how should it appear in the older version?", "answer": "Yes, the line 'g_free(priv->opaque);' was added to the function 'soup_auth_digest_finalize'. In the older version of the file, this line would not be present in the function's implementation."}
{"question": "The patch hunk starts with '@@ -220,7 +220,7 @@'. Does this line number reference change due to lines added in the commit above it? If yes, what would the new line number be for the older version?", "answer": "Yes, the line 'g_free(priv->opaque);' was added above line 220 in the commit. This shifts the lines below by one position. Therefore, the hunk header for the older version should start with '@@ -219,7 +219,7 @@' to reflect the original line positions."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 220
    FUNCTION_SIGNATURE: soup_auth_digest_get_protection_space (SoupAuth *auth, GUri *source_uri)
    HUNK_START_LINE_CONTENT: if (uri &&
    FIRST_CHANGED_LINE_NUMBER: 223
    FIRST_CHANGED_LINE_CONTENT: -           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
    HUNK_LINES:
        if (uri &&
                        g_strcmp0 (g_uri_get_scheme (uri), g_uri_get_scheme (source_uri)) == 0 &&
            g_uri_get_port (uri) == g_uri_get_port (source_uri) &&
-           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
+           !g_strcmp0 (g_uri_get_host (uri), g_uri_get_host (source_uri)))
            dir = g_strdup (g_uri_get_path (uri));
        else
            dir = NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 220
    FUNCTION_SIGNATURE: soup_auth_digest_get_protection_space (SoupAuth *auth, GUri *source_uri)
    HUNK_START_LINE_CONTENT: if (uri &&
    FIRST_CHANGED_LINE_NUMBER: 223
    FIRST_CHANGED_LINE_CONTENT: -           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
    HUNK_LINES:
        if (uri &&
                        g_strcmp0 (g_uri_get_scheme (uri), g_uri_get_scheme (source_uri)) == 0 &&
            g_uri_get_port (uri) == g_uri_get_port (source_uri) &&
-           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
+           !g_strcmp0 (g_uri_get_host (uri), g_uri_get_host (source_uri)))
            dir = g_strdup (g_uri_get_path (uri));
        else
            dir = NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 670
    FIRST_CHANGED_LINE_CONTENT: -    if (pos > resource_length)
    HUNK_LINES:
        look_for_tag:
    -    if (pos > resource_length)
    +    if (pos >= resource_length)
            goto text_html;
        
        if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 670
    FIRST_CHANGED_LINE_CONTENT: -    if (pos > resource_length)
    HUNK_LINES:
        look_for_tag:
    -    if (pos > resource_length)
    +    if (pos >= resource_length)
            goto text_html;
        
        if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: N/A
    HUNK_START_LINE_CONTENT: {'name': 'server'},
    FIRST_CHANGED_LINE_NUMBER: 104
    FIRST_CHANGED_LINE_CONTENT: -  {'name': 'sniffing'},
    HUNK_LINES:
        {'name': 'server'},
    -  {'name': 'sniffing'},
    +  {'name': 'sniffing',
    +    'depends': [test_resources],
    +  },
        {'name': 'ssl',
            'dependencies': [gnutls_dep],
            'depends': mock_pkcs11_module,", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: N/A
    HUNK_START_LINE_CONTENT: {'name': 'server'},
    FIRST_CHANGED_LINE_NUMBER: 104
    FIRST_CHANGED_LINE_CONTENT: -  {'name': 'sniffing'},
    HUNK_LINES:
        {'name': 'server'},
    -  {'name': 'sniffing'},
    +  {'name': 'sniffing',
    +    'depends': [test_resources],
    +  },
        {'name': 'ssl',
            'dependencies': [gnutls_dep],
            'depends': mock_pkcs11_module,"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/sniffing-test.c
    HUNK_START_LINE_NUMBER: 512
    FUNCTION_SIGNATURE: main (int argc, char **argv)
    HUNK_START_LINE_CONTENT: "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",
    FIRST_CHANGED_LINE_NUMBER: 516
    FIRST_CHANGED_LINE_CONTENT: +        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
    HUNK_LINES:
                "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",
                do_sniffing_test);
    
    +        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
    +    g_test_add_data_func ("/sniffing/whitespace",
    +                      "type/text_html/whitespace.html => text/html",
    +                      do_sniffing_test);
    +
            /* Test that disabling the sniffer works correctly */", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/sniffing-test.c
    HUNK_START_LINE_NUMBER: 512
    FUNCTION_SIGNATURE: main (int argc, char **argv)
    HUNK_START_LINE_CONTENT: "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",
    FIRST_CHANGED_LINE_NUMBER: 516
    FIRST_CHANGED_LINE_CONTENT: +        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
    HUNK_LINES:
                "type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8",
                do_sniffing_test);
    
    +        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */
    +    g_test_add_data_func ("/sniffing/whitespace",
    +                      "type/text_html/whitespace.html => text/html",
    +                      do_sniffing_test);
    +
            /* Test that disabling the sniffer works correctly */"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT: +        const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
            *content_type = NULL;
    FIRST_CHANGED_LINE_NUMBER: 303
    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+            g_uri_unref (soup_uri);
+            return NULL;
+        }

        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
            *content_type = NULL;
    FIRST_CHANGED_LINE_NUMBER: 303
    FIRST_CHANGED_LINE_CONTENT: +        path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+            g_uri_unref (soup_uri);
+            return NULL;
+        }

        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT: +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 175
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n");
    HUNK_LINES:
        return NULL;
        split = strstr (start, "\n");
    +   split = g_strstr_len (start, body_end - start, "\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 175
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n");
    HUNK_LINES:
        return NULL;
        split = strstr (start, "\n");
    +   split = g_strstr_len (start, body_end - start, "\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 473
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    +   static void
    +   test_multipart_bounds_good (void)
    +   {
    +   #define TEXT "line1\nline2"
    +   SoupMultipart *multipart;
    +   SoupMessageHeaders *headers, *set_headers = NULL;
    +   GBytes *bytes, *set_bytes = NULL;
    +   const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +   gboolean success;
    +   ...
    +   }
    +   static void
    +   test_multipart_bounds_bad (void)
    +   {
    +   SoupMultipart *multipart;
    +   SoupMessageHeaders *headers;
    +   GBytes *bytes;
    +   const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +   ...
    +   }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 473
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    +   static void
    +   test_multipart_bounds_good (void)
    +   {
    +   #define TEXT "line1\nline2"
    +   SoupMultipart *multipart;
    +   SoupMessageHeaders *headers, *set_headers = NULL;
    +   GBytes *bytes, *set_bytes = NULL;
    +   const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
    +   gboolean success;
    +   ...
    +   }
    +   static void
    +   test_multipart_bounds_bad (void)
    +   {
    +   SoupMultipart *multipart;
    +   SoupMessageHeaders *headers;
    +   GBytes *bytes;
    +   const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
    +   ...
    +   }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:         char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:         char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:         g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1345
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:         g_uri_unref (uri);
    }

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
    static gboolean
    unpause_message (SoupServerMessage *msg)", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:         g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1345
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:         g_uri_unref (uri);
    }

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
    static gboolean
    unpause_message (SoupServerMessage *msg)"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
         * received where a Request-Line is expected."
         */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
         * received where a Request-Line is expected."
         */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;"}
{"question": "The hunk in the patch modifies the function soup_auth_digest_finalize, specifically adding a line to free the opaque member of the private structure. What was the content of this function before the change?", "answer": "Before the change, the function soup_auth_digest_finalize did not include the line g_free(priv->opaque);. This line was added to address memory management of the opaque member."}
{"question": "In the hunk for the function soup_auth_digest_finalize in the file libsoup/auth/soup-auth-digest.c, an additional memory cleanup line was added. How does this affect the memset operation in the function?", "answer": "The memset operation remains unaffected by the addition of g_free(priv->opaque);. This new line is inserted before the memset calls to ensure proper deallocation of memory for the opaque member before clearing other sensitive data."}
{"question": "Was the filename or path for the function soup_auth_digest_finalize altered in the commit affecting this patch hunk?", "answer": "No, the filename and path for the function soup_auth_digest_finalize, located in libsoup/auth/soup-auth-digest.c, remained unchanged in this commit."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 72
    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)
    HUNK_START_LINE_CONTENT:         g_free (priv->cnonce);
    FIRST_CHANGED_LINE_NUMBER: 75
    FIRST_CHANGED_LINE_CONTENT: +        g_free (priv->opaque);
    HUNK_LINES:
        g_free (priv->nonce);
        g_free (priv->domain);
        g_free (priv->cnonce);
+        g_free (priv->opaque);
        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));
        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 72
    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)
    HUNK_START_LINE_CONTENT:         g_free (priv->cnonce);
    FIRST_CHANGED_LINE_NUMBER: 75
    FIRST_CHANGED_LINE_CONTENT: +        g_free (priv->opaque);
    HUNK_LINES:
        g_free (priv->nonce);
        g_free (priv->domain);
        g_free (priv->cnonce);
+        g_free (priv->opaque);
        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));
        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));"}
{"question": "What changes were made to the function 'parse_one_cookie' in the file 'libsoup/cookies/soup-cookie.c'?", "answer": "A check was added to limit the combined length of 'name' and 'value' to 4096 bytes, and free the cookie if exceeded."}
{"question": "What new test function was added in the file 'tests/cookies-test.c'?", "answer": "The test function 'do_cookies_parsing_name_value_max_size' was added to validate the maximum allowed size of cookie names and values."}
{"question": "What test case was registered in the main function of 'tests/cookies-test.c'?", "answer": "The test case '/cookies/parsing/name-value-max-size' was registered for the new test function."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:     const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:     const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 305
    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 305
    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:         gboolean skip_row = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 526
    FIRST_CHANGED_LINE_CONTENT:             while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        gboolean skip_row = FALSE;

-       while ((index_stream < resource_length) &&
+       while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:         gboolean skip_row = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 526
    FIRST_CHANGED_LINE_CONTENT:             while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        gboolean skip_row = FALSE;

-       while ((index_stream < resource_length) &&
+       while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {"}
{"question": "ORIGINAL_HUNK_DATA:
        FILE_PATH: libsoup/soup-session.c
        HUNK_START_LINE_NUMBER: 1230
        FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
        HUNK_START_LINE_CONTENT:         SOUP_ENCODING_NONE);
        FIRST_CHANGED_LINE_NUMBER: 1235
        FIRST_CHANGED_LINE_CONTENT:         /* Strip all credentials on cross-origin redirect. */
        HUNK_LINES:
            SOUP_ENCODING_NONE);

+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
        soup_message_set_uri (msg, new_uri);
        g_uri_unref (new_uri);", "answer": "BACKPORTED_HUNK_DATA:
        FILE_PATH: libsoup/soup-session.c
        HUNK_START_LINE_NUMBER: 1230
        FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
        HUNK_START_LINE_CONTENT:         SOUP_ENCODING_NONE);
        FIRST_CHANGED_LINE_NUMBER: 1235
        FIRST_CHANGED_LINE_CONTENT:         /* Strip all credentials on cross-origin redirect. */
        HUNK_LINES:
            SOUP_ENCODING_NONE);

+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
        soup_message_set_uri (msg, new_uri);
        g_uri_unref (new_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
        FILE_PATH: tests/auth-test.c
        HUNK_START_LINE_NUMBER: 1
        FUNCTION_SIGNATURE: #include "test-utils.h"
        HUNK_START_LINE_CONTENT: #include "test-utils.h"
        FIRST_CHANGED_LINE_NUMBER: 2
        FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
        HUNK_LINES:
            #include "test-utils.h"
+           #include "soup-uri-utils-private.h"", "answer": "BACKPORTED_HUNK_DATA:
        FILE_PATH: tests/auth-test.c
        HUNK_START_LINE_NUMBER: 1
        FUNCTION_SIGNATURE: #include "test-utils.h"
        HUNK_START_LINE_CONTENT: #include "test-utils.h"
        FIRST_CHANGED_LINE_NUMBER: 2
        FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
        HUNK_LINES:
            #include "test-utils.h"
+           #include "soup-uri-utils-private.h""}
{"question": "ORIGINAL_HUNK_DATA:
        FILE_PATH: tests/auth-test.c
        HUNK_START_LINE_NUMBER: 1916
        FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
        HUNK_START_LINE_CONTENT: soup_test_server_quit_unref (server);
        FIRST_CHANGED_LINE_NUMBER: 1917
        FIRST_CHANGED_LINE_CONTENT: +static void
        HUNK_LINES:
            soup_test_server_quit_unref (server);
+
+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}
+
+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}
+
+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}", "answer": "BACKPORTED_HUNK_DATA:
        FILE_PATH: tests/auth-test.c
        HUNK_START_LINE_NUMBER: 1916
        FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
        HUNK_START_LINE_CONTENT: soup_test_server_quit_unref (server);
        FIRST_CHANGED_LINE_NUMBER: 1917
        FIRST_CHANGED_LINE_CONTENT: +static void
        HUNK_LINES:
            soup_test_server_quit_unref (server);
+
+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}
+
+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}
+
+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}"}
{"question": "ORIGINAL_HUNK_DATA:
        FILE_PATH: tests/auth-test.c
        HUNK_START_LINE_NUMBER: 1949
        FUNCTION_SIGNATURE: main (int argc, char **argv)
        HUNK_START_LINE_CONTENT: g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
        FIRST_CHANGED_LINE_NUMBER: 2025
        FIRST_CHANGED_LINE_CONTENT: +        g_test_add_func ("/auth/strip-on-crossorigin-redirect", do_strip_on_crossorigin_redirect);
        HUNK_LINES:
            g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
+        g_test_add_func ("/auth/strip-on-crossorigin-redirect", do_strip_on-crossorigin_redirect);
            g_test_add_data_func ("/auth/missing-params/realm", "Digest qop="auth"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce", "Digest realm="auth-test", qop="auth,auth-int", opaque="5ccc069c403ebaf9f0171e9517f40e41"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce-md5-sess", "Digest realm="auth-test", qop="auth,auth-int", opaque="5ccc069c403ebaf9f0171e9517f40e41" algorithm="MD5-sess"", do_missing_params_test);", "answer": "BACKPORTED_HUNK_DATA:
        FILE_PATH: tests/auth-test.c
        HUNK_START_LINE_NUMBER: 1949
        FUNCTION_SIGNATURE: main (int argc, char **argv)
        HUNK_START_LINE_CONTENT: g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
        FIRST_CHANGED_LINE_NUMBER: 2025
        FIRST_CHANGED_LINE_CONTENT: +        g_test_add_func ("/auth/strip-on-crossorigin-redirect", do_strip-on-crossorigin_redirect);
        HUNK_LINES:
            g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request-on-authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
+        g_test_add_func ("/auth/strip-on-crossorigin-redirect", do_strip-on-crossorigin_redirect);
            g_test_add_data_func ("/auth/missing-params/realm", "Digest qop="auth"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce", "Digest realm="auth-test", qop="auth,auth-int", opaque="5ccc069c403ebaf9f0171e9517f40e41"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce-md5-sess", "Digest realm="auth-test", qop="auth,auth-int", opaque="5ccc069c403ebaf9f0171e9517f40e41" algorithm="MD5-sess"", do_missing_params_test);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 177
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

-       split = strstr (start, "\n\n");
+       split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-multipart.c
    HUNK_START_LINE_NUMBER: 173
    FUNCTION_SIGNATURE: soup_multipart_new_from_message (SoupMessageHeaders *headers,
    HUNK_START_LINE_CONTENT: return NULL;
    FIRST_CHANGED_LINE_NUMBER: 177
    FIRST_CHANGED_LINE_CONTENT: split = g_strstr_len (start, body_end - start, "\n\n");
    HUNK_LINES:
        return NULL;

-       split = strstr (start, "\n\n");
+       split = g_strstr_len (start, body_end - start, "\n\n");
        if (!split || split > end) {
            soup_multipart_free (multipart);
            return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 475
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }

+static void
+test_multipart_bounds_good (void)
+{
+   #define TEXT "line1\nline2"
+   SoupMultipart *multipart;
+   SoupMessageHeaders *headers, *set_headers = NULL;
+   GBytes *bytes, *set_bytes = NULL;
+   const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
+   gboolean success;
+
+   headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+   soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+   bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+   multipart = soup_multipart_new_from_message (headers, bytes);
+
+   g_assert_nonnull (multipart);
+   g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
+   success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
+   g_assert_true (success);
+   g_assert_nonnull (set_headers);
+   g_assert_nonnull (set_bytes);
+   g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
+   g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
+   g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
+
+   soup_message_headers_unref (headers);
+   g_bytes_unref (bytes);
+
+   soup_multipart_free (multipart);
+
+   #undef TEXT
+}
+
+static void
+test_multipart_bounds_bad (void)
+{
+   SoupMultipart *multipart;
+   SoupMessageHeaders *headers;
+   GBytes *bytes;
+   const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
+
+   headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+   soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+   bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+   /* it did read out of raw_data/bytes bounds */
+   multipart = soup_multipart_new_from_message (headers, bytes);
+   g_assert_null (multipart);
+
+   soup_message_headers_unref (headers);
+   g_bytes_unref (bytes);
+}
+
+int
+main (int argc, char **argv)
+{
+   g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
+   g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
+   g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
+   g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
+   g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
+
+   ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/multipart-test.c
    HUNK_START_LINE_NUMBER: 471
    FUNCTION_SIGNATURE: test_multipart (gconstpointer data)
    HUNK_START_LINE_CONTENT: loop = NULL;
    FIRST_CHANGED_LINE_NUMBER: 475
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        loop = NULL;
    }

+static void
+test_multipart_bounds_good (void)
+{
+   #define TEXT "line1\nline2"
+   SoupMultipart *multipart;
+   SoupMessageHeaders *headers, *set_headers = NULL;
+   GBytes *bytes, *set_bytes = NULL;
+   const char *raw_data = "--123\nContent-Type: text/plain;\n\n" TEXT "\n--123--\n";
+   gboolean success;
+
+   headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+   soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+   bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+   multipart = soup_multipart_new_from_message (headers, bytes);
+
+   g_assert_nonnull (multipart);
+   g_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);
+   success = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);
+   g_assert_true (success);
+   g_assert_nonnull (set_headers);
+   g_assert_nonnull (set_bytes);
+   g_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));
+   g_assert_cmpstr ("text/plain", ==, soup_message_headers_get_content_type (set_headers, NULL));
+   g_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));
+
+   soup_message_headers_unref (headers);
+   g_bytes_unref (bytes);
+
+   soup_multipart_free (multipart);
+
+   #undef TEXT
+}
+
+static void
+test_multipart_bounds_bad (void)
+{
+   SoupMultipart *multipart;
+   SoupMessageHeaders *headers;
+   GBytes *bytes;
+   const char *raw_data = "--123\nContent-Type: text/plain;\nline1\nline2\n--123--\n";
+
+   headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
+   soup_message_headers_append (headers, "Content-Type", "multipart/mixed; boundary=\"123\"");
+
+   bytes = g_bytes_new (raw_data, strlen (raw_data));
+
+   /* it did read out of raw_data/bytes bounds */
+   multipart = soup_multipart_new_from_message (headers, bytes);
+   g_assert_null (multipart);
+
+   soup_message_headers_unref (headers);
+   g_bytes_unref (bytes);
+}
+
+int
+main (int argc, char **argv)
+{
+   g_test_add_data_func ("/multipart/sync", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);
+   g_test_add_data_func ("/multipart/async", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);
+   g_test_add_data_func ("/multipart/async-small-reads", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);
+   g_test_add_func ("/multipart/bounds-good", test_multipart_bounds_good);
+   g_test_add_func ("/multipart/bounds-bad", test_multipart_bounds_bad);
+
+   ret = g_test_run ();"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1343
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        g_uri_unref (uri);
}

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
static gboolean
unpause_message (SoupServerMessage *msg)
{", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1343
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        g_uri_unref (uri);
}

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
static gboolean
unpause_message (SoupServerMessage *msg)
{"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 641
    FUNCTION_SIGNATURE: skip_insignificant_space (const char *resource, int *pos, int resource_length)
    HUNK_START_LINE_CONTENT:         (resource[*pos] == '\r')) {
    FIRST_CHANGED_LINE_NUMBER: 644
    FIRST_CHANGED_LINE_CONTENT:         if (*pos >= resource_length)
    HUNK_LINES:
        (resource[*pos] == '\r')) {
        *pos = *pos + 1;

-        if (*pos > resource_length)
+        if (*pos >= resource_length)
            return TRUE;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 641
    FUNCTION_SIGNATURE: skip_insignificant_space (const char *resource, int *pos, int resource_length)
    HUNK_START_LINE_CONTENT:         (resource[*pos] == '\r')) {
    FIRST_CHANGED_LINE_NUMBER: 644
    FIRST_CHANGED_LINE_CONTENT:         if (*pos >= resource_length)
    HUNK_LINES:
        (resource[*pos] == '\r')) {
        *pos = *pos + 1;

-        if (*pos > resource_length)
+        if (*pos >= resource_length)
            return TRUE;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 704
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:         do {
    FIRST_CHANGED_LINE_NUMBER: 708
    FIRST_CHANGED_LINE_CONTENT:             if ((pos + 1) > resource_length)
    HUNK_LINES:
        do {
            pos++;

-            if (pos > resource_length)
+            if ((pos + 1) > resource_length)
                goto text_html;
        } while (resource[pos] != '>');", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 704
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:         do {
    FIRST_CHANGED_LINE_NUMBER: 708
    FIRST_CHANGED_LINE_CONTENT:             if ((pos + 1) > resource_length)
    HUNK_LINES:
        do {
            pos++;

-            if (pos > resource_length)
+            if ((pos + 1) > resource_length)
                goto text_html;
        } while (resource[pos] != '>');"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT:         char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT:             g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-            g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+            g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
        } else {
            /* filename with no value isn't valid. */
            g_hash_table_remove (*params, "filename");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders  *hdrs,
    HUNK_START_LINE_CONTENT:         char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT:             g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-            g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+            g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
        } else {
            /* filename with no value isn't valid. */
            g_hash_table_remove (*params, "filename");"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char          *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 188
    FIRST_CHANGED_LINE_CONTENT:     +   while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -   while ((*str == '\r' || *str == '\n') && len > 0) {
    +   while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char          *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 188
    FIRST_CHANGED_LINE_CONTENT:     +   while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -   while ((*str == '\r' || *str == '\n') && len > 0) {
    +   while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char          *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 373
    FIRST_CHANGED_LINE_CONTENT:     +   while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
    -   while ((*str == '\r' || *str == '\n') && len > 0) {
    +   while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char          *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 373
    FIRST_CHANGED_LINE_CONTENT:     +   while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
    -   while ((*str == '\r' || *str == '\n') && len > 0) {
    +   while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 9
    FIRST_CHANGED_LINE_CONTENT:     +   /* These are not C strings to ensure going one byte over is not safe. */
    HUNK_LINES:
        const char *name, *value;
    +   /* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
                'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +   static char only_newlines[] = {
    +           '\n', '\n', '\n', '\n'
    +   };
    +   
        static struct RequestTest {
            const char *description;
            const char *bugref;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 9
    FIRST_CHANGED_LINE_CONTENT:     +   /* These are not C strings to ensure going one byte over is not safe. */
    HUNK_LINES:
        const char *name, *value;
    +   /* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
                'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +   static char only_newlines[] = {
    +           '\n', '\n', '\n', '\n'
    +   };
    +   
        static struct RequestTest {
            const char *description;
            const char *bugref;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 387
    FUNCTION_SIGNATURE: static struct RequestTest {
    HUNK_START_LINE_CONTENT:         { { NULL } }
    FIRST_CHANGED_LINE_NUMBER: 390
    FIRST_CHANGED_LINE_CONTENT:     -           /* This couldn't be a C string as going one byte over would have been safe. */
    HUNK_LINES:
            { { NULL } }
            },
    -           /* This couldn't be a C string as going one byte over would have been safe. */
            { "Long HTTP version terminating at missing minor version", "https://gitlab.gnome.org/GNOME/libsoup/-/issues/404",
            unterminated_http_version, sizeof (unterminated_http_version),
            SOUP_STATUS_BAD_REQUEST,
    @@ -457,6 +461,13 @@ static struct RequestTest {
            SOUP_STATUS_BAD_REQUEST,
                    NULL, NULL, -1,
    +       },
    +
    +       { "Only newlines", NULL,
    +         only_newlines, sizeof (only_newlines),
    +         SOUP_STATUS_BAD_REQUEST,
    +               NULL, NULL, -1,
    +         { { NULL } }
            }
        };
        static const int num_reqtests = G_N_ELEMENTS (reqtests);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 387
    FUNCTION_SIGNATURE: static struct RequestTest {
    HUNK_START_LINE_CONTENT:         { { NULL } }
    FIRST_CHANGED_LINE_NUMBER: 390
    FIRST_CHANGED_LINE_CONTENT:     -           /* This couldn't be a C string as going one byte over would have been safe. */
    HUNK_LINES:
            { { NULL } }
            },
    -           /* This couldn't be a C string as going one byte over would have been safe. */
            { "Long HTTP version terminating at missing minor version", "https://gitlab.gnome.org/GNOME/libsoup/-/issues/404",
            unterminated_http_version, sizeof (unterminated_http_version),
            SOUP_STATUS_BAD_REQUEST,
    @@ -457,6 +461,13 @@ static struct RequestTest {
            SOUP_STATUS_BAD_REQUEST,
                    NULL, NULL, -1,
    +       },
    +
    +       { "Only newlines", NULL,
    +         only_newlines, sizeof (only_newlines),
    +         SOUP_STATUS_BAD_REQUEST,
    +               NULL, NULL, -1,
    +         { { NULL } }
            }
        };
        static const int num_reqtests = G_N_ELEMENTS (reqtests);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: 	+        if (resource_length < sizeof (guint32))
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
    -	guint32 box_size = *((guint32*)resource);
    +	guint32 box_size;
        guint i;

    +        if (resource_length < sizeof (guint32))
    +                return FALSE;
    +
    +	box_size = *((guint32*)resource);
    +
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: 	+        if (resource_length < sizeof (guint32))
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
    -	guint32 box_size = *((guint32*)resource);
    +	guint32 box_size;
        guint i;

    +        if (resource_length < sizeof (guint32))
    +                return FALSE;
    +
    +	box_size = *((guint32*)resource);
    +
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

+        if (!soup_auth_get_realm (auth))
+                return FALSE;
+
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

+        if (!soup_auth_get_realm (auth))
+                return FALSE;
+
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1869
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+on_request_read_for_missing_realm (SoupServer        *server,
+                                   SoupServerMessage *msg,
+                                   gpointer           user_data)
+{
+        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
+        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
+}
+
+static void
+do_missing_realm_test (void)
+{
+        SoupSession *session;
+        SoupMessage *msg;
+        SoupServer *server;
+        SoupAuthDomain *digest_auth_domain;
+        gint status;
+        GUri *uri;
+
+        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    soup_server_add_handler (server, NULL,
+                 server_callback, NULL, NULL);
+    uri = soup_test_server_get_uri (server, "http", NULL);
+
+    digest_auth_domain = soup_auth_domain_digest_new (
+        "realm", "auth-test",
+        "auth-callback", server_digest_auth_callback,
+        NULL);
+        soup_auth_domain_add_path (digest_auth_domain, "/");
+    soup_server_add_auth_domain (server, digest_auth_domain);
+        g_object_unref (digest_auth_domain);
+
+        g_signal_connect (server, "request-read",
+                          G_CALLBACK (on_request_read_for_missing_realm),
+                          NULL);
+
+        session = soup_test_session_new (NULL);
+        msg = soup_message_new_from_uri ("GET", uri);
+        g_signal_connect (msg, "authenticate",
+                          G_CALLBACK (on_digest_authenticate),
+                          NULL);
+
+        status = soup_test_session_send_message (session, msg);
+
+        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server);
+}
+
    int
    main (int argc, char **argv)
    {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1869
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+on_request_read_for_missing_realm (SoupServer        *server,
+                                   SoupServerMessage *msg,
+                                   gpointer           user_data)
+{
+        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
+        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
+}
+
+static void
+do_missing_realm_test (void)
+{
+        SoupSession *session;
+        SoupMessage *msg;
+        SoupServer *server;
+        SoupAuthDomain *digest_auth_domain;
+        gint status;
+        GUri *uri;
+
+        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    soup_server_add_handler (server, NULL,
+                 server_callback, NULL, NULL);
+    uri = soup_test_server_get_uri (server, "http", NULL);
+
+    digest_auth_domain = soup_auth_domain_digest_new (
+        "realm", "auth-test",
+        "auth-callback", server_digest_auth_callback,
+        NULL);
+        soup_auth_domain_add_path (digest_auth_domain, "/");
+    soup_server_add_auth_domain (server, digest_auth_domain);
+        g_object_unref (digest_auth_domain);
+
+        g_signal_connect (server, "request-read",
+                          G_CALLBACK (on_request_read_for_missing_realm),
+                          NULL);
+
+        session = soup_test_session_new (NULL);
+        msg = soup_message_new_from_uri ("GET", uri);
+        g_signal_connect (msg, "authenticate",
+                          G_CALLBACK (on_digest_authenticate),
+                          NULL);
+
+        status = soup_test_session_send_message (session, msg);
+
+        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server);
+}
+
    int
    main (int argc, char **argv)
    {"}
{"question": "What was added to the function 'do_host_big_header' in the file 'tests/misc-test.c'?", "answer": "Line added: g_clear_error(&error);"}
{"question": "What was added to the function 'redirect_handler' in the file 'tests/misc-test.c'?", "answer": "Line added: g_bytes_unref(body);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)
    HUNK_LINES:
        look_for_tag:
    -    if (pos > resource_length)
    +    if (pos >= resource_length)
            goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT:     +    if (pos >= resource_length)
    HUNK_LINES:
        look_for_tag:
    -    if (pos > resource_length)
    +    if (pos >= resource_length)
            goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        if (content_type)
                *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)
                return NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 289
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);

        if (content_type)
                *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)
                return NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:     +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:     +        { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:         /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:         /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 189
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
        * received where a Request-Line is expected."
        */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char *str,
    HUNK_START_LINE_CONTENT:         * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 374
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
        */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char *str,
    HUNK_START_LINE_CONTENT:         * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 374
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
        * response on that connection.
        */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;
        }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 9
    FIRST_CHANGED_LINE_CONTENT:     +/* These are not C strings to ensure going one byte over is not safe. */
    HUNK_LINES:
        const char *name, *value;
    +/* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
                'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 9
    FIRST_CHANGED_LINE_CONTENT:     +/* These are not C strings to ensure going one byte over is not safe. */
    HUNK_LINES:
        const char *name, *value;
    +/* These are not C strings to ensure going one byte over is not safe. */
        static char unterminated_http_version[] = {
                'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
        };
    +
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 387
    FUNCTION_SIGNATURE: static struct RequestTest {
    HUNK_START_LINE_CONTENT:             { { NULL } }
    FIRST_CHANGED_LINE_NUMBER: 394
    FIRST_CHANGED_LINE_CONTENT:         +        /* This couldn't be a C string as going one byte over would have been safe. */
    HUNK_LINES:
            { { NULL } }
            },
    -        /* This couldn't be a C string as going one byte over would have been safe. */
            { "Long HTTP version terminating at missing minor version", "https://gitlab.gnome.org/GNOME/libsoup/-/issues/404",
            unterminated_http_version, sizeof (unterminated_http_version),
            SOUP_STATUS_BAD_REQUEST,
    @@ -457,6 +461,13 @@ static struct RequestTest {
            SOUP_STATUS_BAD_REQUEST,
                    NULL, NULL, -1,
    +	},
    +
    +	{ "Only newlines", NULL,
    +	  only_newlines, sizeof (only_newlines),
    +	  SOUP_STATUS_BAD_REQUEST,
    +            NULL, NULL, -1,
    +	  { { NULL } }
            }
        };
        static const int num_reqtests = G_N_ELEMENTS (reqtests);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 387
    FUNCTION_SIGNATURE: static struct RequestTest {
    HUNK_START_LINE_CONTENT:             { { NULL } }
    FIRST_CHANGED_LINE_NUMBER: 394
    FIRST_CHANGED_LINE_CONTENT:         +        /* This couldn't be a C string as going one byte over would have been safe. */
    HUNK_LINES:
            { { NULL } }
            },
    -        /* This couldn't be a C string as going one byte over would have been safe. */
            { "Long HTTP version terminating at missing minor version", "https://gitlab.gnome.org/GNOME/libsoup/-/issues/404",
            unterminated_http_version, sizeof (unterminated_http_version),
            SOUP_STATUS_BAD_REQUEST,
    @@ -457,6 +461,13 @@ static struct RequestTest {
            SOUP_STATUS_BAD_REQUEST,
                    NULL, NULL, -1,
    +	},
    +
    +	{ "Only newlines", NULL,
    +	  only_newlines, sizeof (only_newlines),
    +	  SOUP_STATUS_BAD_REQUEST,
    +            NULL, NULL, -1,
    +	  { { NULL } }
            }
        };
        static const int num_reqtests = G_N_ELEMENTS (reqtests);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 150
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

        if (!soup_auth_get_realm (auth))
                return FALSE;

        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 150
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

        if (!soup_auth_get_realm (auth))
                return FALSE;

        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    static void
    on_request_read_for_missing_realm (SoupServer        *server,
                                       SoupServerMessage *msg,
                                       gpointer           user_data)
    {
            SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
            soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
    }

    static void
    do_missing_realm_test (void)
    {
            SoupSession *session;
            SoupMessage *msg;
            SoupServer *server;
            SoupAuthDomain *digest_auth_domain;
            gint status;
            GUri *uri;

            server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
            soup_server_add_handler (server, NULL,
                                     server_callback, NULL, NULL);
            uri = soup_test_server_get_uri (server, "http", NULL);

            digest_auth_domain = soup_auth_domain_digest_new (
                "realm", "auth-test",
                "auth-callback", server_digest_auth_callback,
                NULL);
            soup_auth_domain_add_path (digest_auth_domain, "/");
            soup_server_add_auth_domain (server, digest_auth_domain);
            g_object_unref (digest_auth_domain);

            g_signal_connect (server, "request-read",
                              G_CALLBACK (on_request_read_for_missing_realm),
                              NULL);

            session = soup_test_session_new (NULL);
            msg = soup_message_new_from_uri ("GET", uri);
            g_signal_connect (msg, "authenticate",
                              G_CALLBACK (on_digest_authenticate),
                              NULL);

            status = soup_test_session_send_message (session, msg);

            g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
            g_uri_unref (uri);
            soup_test_server_quit_unref (server);
    }", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    static void
    on_request_read_for_missing_realm (SoupServer        *server,
                                       SoupServerMessage *msg,
                                       gpointer           user_data)
    {
            SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
            soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
    }

    static void
    do_missing_realm_test (void)
    {
            SoupSession *session;
            SoupMessage *msg;
            SoupServer *server;
            SoupAuthDomain *digest_auth_domain;
            gint status;
            GUri *uri;

            server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
            soup_server_add_handler (server, NULL,
                                     server_callback, NULL, NULL);
            uri = soup_test_server_get_uri (server, "http", NULL);

            digest_auth_domain = soup_auth_domain_digest_new (
                "realm", "auth-test",
                "auth-callback", server_digest_auth_callback,
                NULL);
            soup_auth_domain_add_path (digest_auth_domain, "/");
            soup_server_add_auth_domain (server, digest_auth_domain);
            g_object_unref (digest_auth_domain);

            g_signal_connect (server, "request-read",
                              G_CALLBACK (on_request_read_for_missing_realm),
                              NULL);

            session = soup_test_session_new (NULL);
            msg = soup_message_new_from_uri ("GET", uri);
            g_signal_connect (msg, "authenticate",
                              G_CALLBACK (on_digest_authenticate),
                              NULL);

            status = soup_test_session_send_message (session, msg);

            g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
            g_uri_unref (uri);
            soup_test_server_quit_unref (server);"}
{"question": "In the file 'libsoup/server/http2/soup-server-message-io-http2.c', what changes were made to the conditional check for the validity of the 'msg_io->scheme' and 'msg_io->path'?", "answer": "The checks were modified to allow 'msg_io->scheme' and 'msg_io->path' to be unset, as per RFC 5740."}
{"question": "What adjustments were made to the decrement of 'io->in_callback' in the file 'libsoup/server/http2/soup-server-message-io-http2.c'?", "answer": "Decrementing 'io->in_callback' was added before early returns in the function."}
{"question": "What changes were made to handle the unset 'scheme' and 'path' when constructing the URI string in the file 'libsoup/server/http2/soup-server-message-io-http2.c'?", "answer": "The URI string construction was updated to handle unset 'scheme' and 'path' by providing default values."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 306
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 299
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 304
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:         guint index_pattern = 0;
    FIRST_CHANGED_LINE_NUMBER: 527
    FIRST_CHANGED_LINE_CONTENT:             while ((index_stream < resource_length) &&
    HUNK_LINES:
        guint index_pattern = 0;
        gboolean skip_row = FALSE;

-       while ((index_stream < resource_length) &&
+       while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:         guint index_pattern = 0;
    FIRST_CHANGED_LINE_NUMBER: 527
    FIRST_CHANGED_LINE_CONTENT:             while ((index_stream < resource_length) &&
    HUNK_LINES:
        guint index_pattern = 0;
        gboolean skip_row = FALSE;

-       while ((index_stream < resource_length) &&
+       while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {"}
{"question": "The patch hunk's function `on_frame_recv_callback` in `libsoup/server/http2/soup-server-message-io-http2.c` contains a check for NULL values of `scheme`, `authority`, and `path`. Were these checks modified in the commit? If so, what was the original version of these checks?", "answer": "Yes, the checks were modified. In the original version, the function returned `NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` if `scheme`, `authority`, or `path` were NULL. The modified version only checks for `authority` being NULL and adjusts the handling accordingly."}
{"question": "The patch hunk includes a line setting the `uri_string` variable using `g_strdup_printf`. Was this line modified in the commit? If so, what was the original version of this line?", "answer": "Yes, the line was modified. In the original version, the `uri_string` was constructed using `scheme`, `authority`, and `path` without condition. In the updated version, the `path` is conditionally included, defaulting to an empty string if NULL."}
{"question": "The patch hunk includes a return statement for NULL `uri` in `libsoup/server/http2/soup-server-message-io-http2.c`. Was this handling altered in the commit? If so, what was the original behavior?", "answer": "Yes, the handling was altered. Originally, the function returned `NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` directly when `uri` was NULL. The updated version decrements `io->in_callback` before returning the error."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:     char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:     char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1344
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        g_uri_unref (uri);

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
 static gboolean
 unpause_message (SoupServerMessage *msg)
 {

@@ -1662,6 +1686,10 @@ main (int argc, char **argv)
 setup_session,
 do_connection_closed_test,
 teardown_session);
+        g_test_add ("/http2/broken-pseudo-header", Test, NULL,
+                    setup_session,
+                    do_broken_pseudo_header_test,
+                    teardown_session);

ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1344
    FIRST_CHANGED_LINE_CONTENT: static void
    HUNK_LINES:
        g_uri_unref (uri);

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
 static gboolean
 unpause_message (SoupServerMessage *msg)
 {

@@ -1662,6 +1686,10 @@ main (int argc, char **argv)
 setup_session,
 do_connection_closed_test,
 teardown_session);
+        g_test_add ("/http2/broken-pseudo-header", Test, NULL,
+                    setup_session,
+                    do_broken_pseudo_header_test,
+                    teardown_session);

ret = g_test_run ();"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 188
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
         * received where a Request-Line is expected."
         */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 186
    FUNCTION_SIGNATURE: soup_headers_parse_request (const char *str,
    HUNK_START_LINE_CONTENT:     /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
    FIRST_CHANGED_LINE_NUMBER: 188
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        /* RFC 2616 4.1 "servers SHOULD ignore any empty line(s)
         * received where a Request-Line is expected."
         */
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 373
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
         * response on that connection.
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 371
    FUNCTION_SIGNATURE: soup_headers_parse_response (const char *str,
    HUNK_START_LINE_CONTENT:     * after a response, which we then see prepended to the next
    FIRST_CHANGED_LINE_NUMBER: 373
    FIRST_CHANGED_LINE_CONTENT:     +    while (len > 0 && (*str == '\r' || *str == '\n')) {
    HUNK_LINES:
        * after a response, which we then see prepended to the next
         * response on that connection.
    -    while ((*str == '\r' || *str == '\n') && len > 0) {
    +    while (len > 0 && (*str == '\r' || *str == '\n')) {
            str++;
            len--;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 8
    FIRST_CHANGED_LINE_CONTENT:     +static char unterminated_http_version[] = {
    HUNK_LINES:
        const char *name, *value;
    +static char unterminated_http_version[] = {
    +        'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
    +};
    +
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/header-parsing-test.c
    HUNK_START_LINE_NUMBER: 6
    FUNCTION_SIGNATURE: typedef struct {
    HUNK_START_LINE_CONTENT:     const char *name, *value;
    FIRST_CHANGED_LINE_NUMBER: 8
    FIRST_CHANGED_LINE_CONTENT:     +static char unterminated_http_version[] = {
    HUNK_LINES:
        const char *name, *value;
    +static char unterminated_http_version[] = {
    +        'G','E','T',' ','/',' ','H','T','T','P','/','1', '0', '0', '.'
    +};
    +
    +static char only_newlines[] = {
    +        '\n', '\n', '\n', '\n'
    +};"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 150
    FIRST_CHANGED_LINE_CONTENT: +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

+        if (!soup_auth_get_realm (auth))
+                return FALSE;
+
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    File_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 150
    FIRST_CHANGED_LINE_CONTENT: +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;

+        if (!soup_auth_get_realm (auth))
+                return FALSE;
+
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1868
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+on_request_read_for_missing_realm (SoupServer        *server,
+                                   SoupServerMessage *msg,
+                                   gpointer           user_data)
+{
+        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
+        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
+}
+
+static void
+do_missing_realm_test (void)
+{
+        SoupSession *session;
+        SoupMessage *msg;
+        SoupServer *server;
+        SoupAuthDomain *digest_auth_domain;
+        gint status;
+        GUri *uri;
+
+        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    soup_server_add_handler (server, NULL,
+                 server_callback, NULL, NULL);
+    uri = soup_test_server_get_uri (server, "http", NULL);
+
+    digest_auth_domain = soup_auth_domain_digest_new (
+        "realm", "auth-test",
+        "auth-callback", server_digest_auth_callback,
+        NULL);
+        soup_auth_domain_add_path (digest_auth_domain, "/");
+    soup_server_add_auth_domain (server, digest_auth_domain);
+        g_object_unref (digest_auth_domain);
+
+        g_signal_connect (server, "request-read",
+                          G_CALLBACK (on_request_read_for_missing_realm),
+                          NULL);
+
+        session = soup_test_session_new (NULL);
+        msg = soup_message_new_from_uri ("GET", uri);
+        g_signal_connect (msg, "authenticate",
+                          G_CALLBACK (on_digest_authenticate),
+                          NULL);
+
+        status = soup_test_session_send_message (session, msg);
+
+        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server);
+}
+
    int
    main (int argc, char **argv)
    {
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
        g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
        g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
+        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);

        ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
    File_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1868
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

+static void
+on_request_read_for_missing_realm (SoupServer        *server,
+                                   SoupServerMessage *msg,
+                                   gpointer           user_data)
+{
+        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
+        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop=\"auth\"");
+}
+
+static void
+do_missing_realm_test (void)
+{
+        SoupSession *session;
+        SoupMessage *msg;
+        SoupServer *server;
+        SoupAuthDomain *digest_auth_domain;
+        gint status;
+        GUri *uri;
+
+        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    soup_server_add_handler (server, NULL,
+                 server_callback, NULL, NULL);
+    uri = soup_test_server_get_uri (server, "http", NULL);
+
+    digest_auth_domain = soup_auth_domain_digest_new (
+        "realm", "auth-test",
+        "auth-callback", server_digest_auth_callback,
+        NULL);
+        soup_auth_domain_add_path (digest_auth_domain, "/");
+    soup_server_add_auth_domain (server, digest_auth_domain);
+        g_object_unref (digest_auth_domain);
+
+        g_signal_connect (server, "request-read",
+                          G_CALLBACK (on_request_read_for_missing_realm),
+                          NULL);
+
+        session = soup_test_session_new (NULL);
+        msg = soup_message_new_from_uri ("GET", uri);
+        g_signal_connect (msg, "authenticate",
+                          G_CALLBACK (on_digest_authenticate),
+                          NULL);
+
+        status = soup_test_session_send_message (session, msg);
+
+        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server);
+}
+
    int
    main (int argc, char **argv)
    {
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
        g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
        g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
+        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);

        ret = g_test_run ();"}
{"question": "What change was made to the function 'parse_one_cookie' in the file 'libsoup/cookies/soup-cookie.c'?", "answer": "A conditional block was added to check if both 'cookie->name' and 'cookie->value' are empty and return NULL after freeing the cookie."}
{"question": "What lines were added to the file 'libsoup/cookies/soup-cookie.c' in the function 'parse_one_cookie'?", "answer": "Lines were added to check for empty cookie names and values, free the cookie, and return NULL if both are empty."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:     const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:     const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 304
    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 304
    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:     { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:     { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders *hdrs,
    HUNK_START_LINE_CONTENT: char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-            g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+            g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-message-headers.c
    HUNK_START_LINE_NUMBER: 1664
    FUNCTION_SIGNATURE: soup_message_headers_get_content_disposition (SoupMessageHeaders *hdrs,
    HUNK_START_LINE_CONTENT: char *filename = strrchr (orig_value, '/');
    FIRST_CHANGED_LINE_NUMBER: 1666
    FIRST_CHANGED_LINE_CONTENT: -                                g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
    HUNK_LINES:
        char *filename = strrchr (orig_value, '/');

        if (filename)
-            g_hash_table_insert (*params, g_strdup (orig_key), filename + 1);
+            g_hash_table_insert (*params, g_strdup (orig_key), g_strdup (filename + 1));
    } else {
        /* filename with no value isn't valid. */
        g_hash_table_remove (*params, "filename");"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:     +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT:     +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    +
    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop="auth"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
        int
        main (int argc, char **argv)
        {
    @@ -1899,6 +1948,7 @@ main (int argc, char **argv)
            g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
                g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
                g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    +
    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop="auth"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
        int
        main (int argc, char **argv)
        {
    @@ -1899,6 +1948,7 @@ main (int argc, char **argv)
            g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
                g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
                g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);"}
{"question": "What change was made to the loop structure in the function 'soup_message_headers_get_ranges_internal' in the file 'libsoup/soup-message-headers.c'?", "answer": "A decrement of 'i' was added after removing an array index to correct skipping logic."}
{"question": "What new test case was added to the 'tests/meson.build' file?", "answer": "The 'server-mem-limit' test case was added to the tests array."}
{"question": "What is the purpose of the newly added file 'tests/server-mem-limit-test.c'?", "answer": "It introduces tests to validate server memory limit handling and range overlap scenarios."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 220
    FUNCTION_SIGNATURE: soup_auth_digest_get_protection_space (SoupAuth *auth, GUri *source_uri)
    HUNK_START_LINE_CONTENT:     if (uri &&
    FIRST_CHANGED_LINE_NUMBER: 223
    FIRST_CHANGED_LINE_CONTENT: -           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
    HUNK_LINES:
        if (uri &&
                        g_strcmp0 (g_uri_get_scheme (uri), g_uri_get_scheme (source_uri)) == 0 &&
            g_uri_get_port (uri) == g_uri_get_port (source_uri) &&
-           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
+           !g_strcmp0 (g_uri_get_host (uri), g_uri_get_host (source_uri)))
                dir = g_strdup (g_uri_get_path (uri));
            else
                dir = NULL;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 220
    FUNCTION_SIGNATURE: soup_auth_digest_get_protection_space (SoupAuth *auth, GUri *source_uri)
    HUNK_START_LINE_CONTENT:     if (uri &&
    FIRST_CHANGED_LINE_NUMBER: 223
    FIRST_CHANGED_LINE_CONTENT: -           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
    HUNK_LINES:
        if (uri &&
                        g_strcmp0 (g_uri_get_scheme (uri), g_uri_get_scheme (source_uri)) == 0 &&
            g_uri_get_port (uri) == g_uri_get_port (source_uri) &&
-           !strcmp (g_uri_get_host (uri), g_uri_get_host (source_uri)))
+           !g_strcmp0 (g_uri_get_host (uri), g_uri_get_host (source_uri)))
                dir = g_strdup (g_uri_get_path (uri));
            else
                dir = NULL;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 670
    FIRST_CHANGED_LINE_CONTENT:     -   if (pos > resource_length)
    HUNK_LINES:
        look_for_tag:
    -   if (pos > resource_length)
    +   if (pos >= resource_length)
            goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT: look_for_tag:
    FIRST_CHANGED_LINE_NUMBER: 670
    FIRST_CHANGED_LINE_CONTENT:     -   if (pos > resource_length)
    HUNK_LINES:
        look_for_tag:
    -   if (pos > resource_length)
    +   if (pos >= resource_length)
            goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: None
    HUNK_START_LINE_CONTENT: tests = [
    FIRST_CHANGED_LINE_NUMBER: 107
    FIRST_CHANGED_LINE_CONTENT:     +  {'name': 'sniffing',
    HUNK_LINES:
        tests = [
            {'name': 'session'},
            {'name': 'server-auth'},
            {'name': 'server'},
        -   {'name': 'sniffing'},
        +   {'name': 'sniffing',
        +     'depends': [test_resources],
        +   },
            {'name': 'ssl',
                'dependencies': [gnutls_dep],
                'depends': mock_pkcs11_module,", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/meson.build
    HUNK_START_LINE_NUMBER: 103
    FUNCTION_SIGNATURE: None
    HUNK_START_LINE_CONTENT: tests = [
    FIRST_CHANGED_LINE_NUMBER: 107
    FIRST_CHANGED_LINE_CONTENT:     +  {'name': 'sniffing',
    HUNK_LINES:
        tests = [
            {'name': 'session'},
            {'name': 'server-auth'},
            {'name': 'server'},
        -   {'name': 'sniffing'},
        +   {'name': 'sniffing',
        +     'depends': [test_resources],
        +   },
            {'name': 'ssl',
                'dependencies': [gnutls_dep],
                'depends': mock_pkcs11_module,"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 290
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 307
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:     if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 307
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }
+
        uri_string = g_uri_to_string (soup_uri);
        g_uri_unref (soup_uri);
        if (!uri_string)"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:     { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:         }

    +        /* Strip all credentials on cross-origin redirect. */
    FIRST_CHANGED_LINE_NUMBER: 1236
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        }

    +        /* Strip all credentials on cross-origin redirect. */
    +        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    +                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
    +                soup_message_set_auth (msg, NULL);
    +        }
    +
            soup_message_set_request_host_from_uri (msg, new_uri);
        soup_message_set_uri (msg, new_uri);
        g_uri_unref (new_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT:         }

    +        /* Strip all credentials on cross-origin redirect. */
    FIRST_CHANGED_LINE_NUMBER: 1236
    FIRST_CHANGED_LINE_CONTENT:         if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    HUNK_LINES:
        }

    +        /* Strip all credentials on cross-origin redirect. */
    +        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
    +                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
    +                soup_message_set_auth (msg, NULL);
    +        }
    +
            soup_message_set_request_host_from_uri (msg, new_uri);
        soup_message_set_uri (msg, new_uri);
        g_uri_unref (new_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);

    +static void
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    +static void
    +redirect_server_callback (SoupServer        *server,
    +                          SoupServerMessage *msg,
    +                          const char        *path,
    +                          GHashTable        *query,
    +                          gpointer           user_data)
    +{
    +    static gboolean redirected = FALSE;
    +
    +    if (!redirected) {
    +        char *redirect_uri = g_uri_to_string (user_data);
    +        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
    +        g_free (redirect_uri);
    +        redirected = TRUE;
    +        return;
    +    }
    +
    +    g_assert_not_reached ();
    +}

    +static gboolean
    +auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
    +{
    +    GUri *known_server_uri = user_data;
    +
    +    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
    +        return FALSE;
    +
    +    soup_auth_authenticate (auth, "user", "good-basic");
    +
    +    return TRUE;
    +}

    +static void
    +do_strip_on_crossorigin_redirect (void)
    +{
    +    SoupSession *session;
    +    SoupMessage *msg;
    +    SoupServer *server1, *server2;
    +    SoupAuthDomain *auth_domain;
    +    GUri *uri;
    +    gint status;
    +
    +    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +
    +    /* Both servers have the same credentials. */
    +    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
    +    soup_auth_domain_add_path (auth_domain, "/");
    +    soup_server_add_auth_domain (server1, auth_domain);
    +    soup_server_add_auth_domain (server2, auth_domain);
    +    g_object_unref (auth_domain);
    +
    +    /* Server 1 asks for auth, then redirects to Server 2. */
    +    soup_server_add_handler (server1, NULL,
    +                    redirect_server_callback,
    +                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
    +    /* Server 2 requires auth. */
    +    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
    +
    +    session = soup_test_session_new (NULL);
    +    uri = soup_test_server_get_uri (server1, "http", NULL);
    +    msg = soup_message_new_from_uri ("GET", uri);
    +    /* The client only sends credentials for the host it knows. */
    +    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
    +
    +    status = soup_test_session_send_message (session, msg);
    +
    +    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +
    +    g_uri_unref (uri);
    +    soup_test_server_quit_unref (server1);
    +    soup_test_server_quit_unref (server2);
    +}

        int
        main (int argc, char **argv)
        {
    @@ -1949,6 +2025,7 @@ main (int argc, char **argv)
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/strip-on-crossorigin-redirect", do_strip_on_crossorigin_redirect);
            g_test_add_data_func ("/auth/missing-params/realm", "Digest qop=\"auth\"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce", "Digest realm=\"auth-test\", qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce-md5-sess", "Digest realm=\"auth-test\", qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\" algorithm=\"MD5-sess\"", do_missing_params_test);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);

    +static void
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    }

    +static void
    +redirect_server_callback (SoupServer        *server,
    +                          SoupServerMessage *msg,
    +                          const char        *path,
    +                          GHashTable        *query,
    +                          gpointer           user_data)
    +{
    +    static gboolean redirected = FALSE;
    +
    +    if (!redirected) {
    +        char *redirect_uri = g_uri_to_string (user_data);
    +        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
    +        g_free (redirect_uri);
    +        redirected = TRUE;
    +        return;
    +    }
    +
    +    g_assert_not_reached ();
    +}

    +static gboolean
    +auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
    +{
    +    GUri *known_server_uri = user_data;
    +
    +    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
    +        return FALSE;
    +
    +    soup_auth_authenticate (auth, "user", "good-basic");
    +
    +    return TRUE;
    +}

    +static void
    +do_strip_on_crossorigin_redirect (void)
    +{
    +    SoupSession *session;
    +    SoupMessage *msg;
    +    SoupServer *server1, *server2;
    +    SoupAuthDomain *auth_domain;
    +    GUri *uri;
    +    gint status;
    +
    +    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +
    +    /* Both servers have the same credentials. */
    +    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
    +    soup_auth_domain_add_path (auth_domain, "/");
    +    soup_server_add_auth_domain (server1, auth_domain);
    +    soup_server_add_auth_domain (server2, auth_domain);
    +    g_object_unref (auth_domain);
    +
    +    /* Server 1 asks for auth, then redirects to Server 2. */
    +    soup_server_add_handler (server1, NULL,
    +                    redirect_server_callback,
    +                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
    +    /* Server 2 requires auth. */
    +    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
    +
    +    session = soup_test_session_new (NULL);
    +    uri = soup_test_server_get_uri (server1, "http", NULL);
    +    msg = soup_message_new_from_uri ("GET", uri);
    +    /* The client only sends credentials for the host it knows. */
    +    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
    +
    +    status = soup_test_session_send_message (session, msg);
    +
    +    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +
    +    g_uri_unref (uri);
    +    soup_test_server_quit_unref (server1);
    +    soup_test_server_quit_unref (server2);
    +}

        int
        main (int argc, char **argv)
        {
    @@ -1949,6 +2025,7 @@ main (int argc, char **argv)
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/strip-on-crossorigin-redirect", do_strip_on_crossorigin_redirect);
            g_test_add_data_func ("/auth/missing-params/realm", "Digest qop=\"auth\"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce", "Digest realm=\"auth-test\", qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"", do_missing_params_test);
            g_test_add_data_func ("/auth/missing-params/nonce-md5-sess", "Digest realm=\"auth-test\", qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\" algorithm=\"MD5-sess\"", do_missing_params_test);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         +        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/server/http2/soup-server-message-io-http2.c
    HUNK_START_LINE_NUMBER: 771
    FUNCTION_SIGNATURE: on_frame_recv_callback (nghttp2_session     *session,
    HUNK_START_LINE_CONTENT:         char *uri_string;
    FIRST_CHANGED_LINE_NUMBER: 773
    FIRST_CHANGED_LINE_CONTENT:         +        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
    HUNK_LINES:
        char *uri_string;
        GUri *uri;

+        if (msg_io->scheme == NULL || msg_io->authority == NULL || msg_io->path == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        uri_string = g_strdup_printf ("%s://%s%s", msg_io->scheme, msg_io->authority, msg_io->path);
        uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
        g_free (uri_string);
+        if (uri == NULL)
+            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
        soup_server_message_set_uri (msg_io->msg, uri);
        g_uri_unref (uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1343
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        g_uri_unref (uri);

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
    static gboolean
    unpause_message (SoupServerMessage *msg)
    {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/http2-test.c
    HUNK_START_LINE_NUMBER: 1341
    FUNCTION_SIGNATURE: do_connection_closed_test (Test *test, gconstpointer data)
    HUNK_START_LINE_CONTENT:     g_uri_unref (uri);
    FIRST_CHANGED_LINE_NUMBER: 1343
    FIRST_CHANGED_LINE_CONTENT:     +static void
    HUNK_LINES:
        g_uri_unref (uri);

+static void
+do_broken_pseudo_header_test (Test *test, gconstpointer data)
+{
+    char *path;
+    SoupMessage *msg;
+    GUri *uri;
+    GBytes *body = NULL;
+    GError *error = NULL;
+
+    uri = g_uri_parse_relative (base_uri, "/ag", SOUP_HTTP_URI_FLAGS, NULL);
+
+    /* an ugly cheat to construct a broken URI, which can be sent from other libs */
+    path = (char *) g_uri_get_path (uri);
+    path[1] = '%';
+
+    msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+    body = soup_test_session_async_send (test->session, msg, NULL, &error);
+    g_assert_error (error, G_IO_ERROR, G_IO_ERROR_PARTIAL_INPUT);
+    g_assert_null (body);
+    g_clear_error (&error);
+    g_object_unref (msg);
+    g_uri_unref (uri);
+}
+
    static gboolean
    unpause_message (SoupServerMessage *msg)
    {"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: 	+    guint32 box_size;
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
    -	guint32 box_size = *((guint32*)resource);
    +	guint32 box_size;
        guint i;
    +        if (resource_length < sizeof (guint32))
    +                return FALSE;
    +
    +	box_size = *((guint32*)resource);
    +
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 243
    FUNCTION_SIGNATURE: sniff_mp4 (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:     gsize resource_length;
    FIRST_CHANGED_LINE_NUMBER: 246
    FIRST_CHANGED_LINE_CONTENT: 	+    guint32 box_size;
    HUNK_LINES:
        gsize resource_length;
        const char *resource = g_bytes_get_data (buffer, &resource_length);
        resource_length = MIN (512, resource_length);
    -	guint32 box_size = *((guint32*)resource);
    +	guint32 box_size;
        guint i;
    +        if (resource_length < sizeof (guint32))
    +                return FALSE;
    +
    +	box_size = *((guint32*)resource);
    +
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        box_size = ((box_size >> 24) |
                ((box_size << 8) & 0x00FF0000) |"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT: +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/auth/soup-auth-digest.c
    HUNK_START_LINE_NUMBER: 148
    FUNCTION_SIGNATURE: soup_auth_digest_update (SoupAuth *auth, SoupMessage *msg,
    HUNK_START_LINE_CONTENT:     guint qop_options;
    FIRST_CHANGED_LINE_NUMBER: 151
    FIRST_CHANGED_LINE_CONTENT: +        if (!soup_auth_get_realm (auth))
    HUNK_LINES:
        guint qop_options;
        gboolean ok = TRUE;
    +        if (!soup_auth_get_realm (auth))
    +                return FALSE;
    +
        g_free (priv->domain);
        g_free (priv->nonce);
        g_free (priv->opaque);"}
{"question": "ORIGINAL_HUNK_DATA:
    File_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop="auth"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
        int
        main (int argc, char **argv)
        {
    @@ -1899,6 +1948,7 @@ main (int argc, char **argv)
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);
    
        ret = g_test_run ();", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1866
    FUNCTION_SIGNATURE: do_multiple_digest_algorithms (void)
    HUNK_START_LINE_CONTENT:     soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1867
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
    +static void
    +on_request_read_for_missing_realm (SoupServer        *server,
    +                                   SoupServerMessage *msg,
    +                                   gpointer           user_data)
    +{
    +        SoupMessageHeaders *response_headers = soup_server_message_get_response_headers (msg);
    +        soup_message_headers_replace (response_headers, "WWW-Authenticate", "Digest qop="auth"");
    +}
    +
    +static void
    +do_missing_realm_test (void)
    +{
    +        SoupSession *session;
    +        SoupMessage *msg;
    +        SoupServer *server;
    +        SoupAuthDomain *digest_auth_domain;
    +        gint status;
    +        GUri *uri;
    +
    +        server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
    +	soup_server_add_handler (server, NULL,
    +				 server_callback, NULL, NULL);
    +	uri = soup_test_server_get_uri (server, "http", NULL);
    +
    +	digest_auth_domain = soup_auth_domain_digest_new (
    +		"realm", "auth-test",
    +		"auth-callback", server_digest_auth_callback,
    +		NULL);
    +        soup_auth_domain_add_path (digest_auth_domain, "/");
    +	soup_server_add_auth_domain (server, digest_auth_domain);
    +        g_object_unref (digest_auth_domain);
    +
    +        g_signal_connect (server, "request-read",
    +                          G_CALLBACK (on_request_read_for_missing_realm),
    +                          NULL);
    +
    +        session = soup_test_session_new (NULL);
    +        msg = soup_message_new_from_uri ("GET", uri);
    +        g_signal_connect (msg, "authenticate",
    +                          G_CALLBACK (on_digest_authenticate),
    +                          NULL);
    +
    +        status = soup_test_session_send_message (session, msg);
    +
    +        g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
    +	g_uri_unref (uri);
    +	soup_test_server_quit_unref (server);
    +}
    +
        int
        main (int argc, char **argv)
        {
    @@ -1899,6 +1948,7 @@ main (int argc, char **argv)
        g_test_add_func ("/auth/auth-uri", do_auth_uri_test);
            g_test_add_func ("/auth/cancel-request-on-authenticate", do_cancel_request_on_authenticate);
            g_test_add_func ("/auth/multiple-algorithms", do_multiple_digest_algorithms);
    +        g_test_add_func ("/auth/missing-realm", do_missing_realm_test);
    
        ret = g_test_run ();"}
{"question": "What new file was added to the codebase in the tests directory?", "answer": "File ws-test-helper.c was added."}
{"question": "What changes were made to the tests/meson.build file regarding executable definitions?", "answer": "Added executable definition for ws-test-helper with dependencies and installation parameters."}
{"question": "What is the purpose of the newly added file ws-test-helper.c?", "answer": "Provides a helper for testing SoupWebsocketConnection with valgrind."}
{"question": "What new function was introduced in ws-test-helper.c for handling SIGINT signals?", "answer": "Function on_sigint was introduced."}
{"question": "What changes were made to the logic for handling WebSocket connections?", "answer": "Added keepalive interval and pong timeout settings to SoupWebsocketConnection."}
{"question": "What modifications were made to the main function in ws-test-helper.c?", "answer": "Implemented WebSocket connection setup and main loop for event handling."}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:         pos = 3;
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT: +	if (pos >= resource_length)
    HUNK_LINES:
        pos = 3;

look_for_tag:
-       if (pos > resource_length)
+       if (pos >= resource_length)
        goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 669
    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)
    HUNK_START_LINE_CONTENT:         pos = 3;
    FIRST_CHANGED_LINE_NUMBER: 672
    FIRST_CHANGED_LINE_CONTENT: +	if (pos >= resource_length)
    HUNK_LINES:
        pos = 3;

look_for_tag:
-       if (pos > resource_length)
+       if (pos >= resource_length)
        goto text_html;

        if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 907
    FUNCTION_SIGNATURE: append_param_quoted (GString    *string,
    HUNK_START_LINE_CONTENT:         const char *name,
    FIRST_CHANGED_LINE_NUMBER: 910
    FIRST_CHANGED_LINE_CONTENT: -	int len;
    HUNK_LINES:
        const char *name,
        const char *value)
{
-	int len;
+	gsize len;

    g_string_append (string, name);
    g_string_append (string, "=");", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 907
    FUNCTION_SIGNATURE: append_param_quoted (GString    *string,
    HUNK_START_LINE_CONTENT:         const char *name,
    FIRST_CHANGED_LINE_NUMBER: 910
    FIRST_CHANGED_LINE_CONTENT: -	int len;
    HUNK_LINES:
        const char *name,
        const char *value)
{
-	int len;
+	gsize len;

    g_string_append (string, name);
    g_string_append (string, "=");"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 291
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 286
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;
    FIRST_CHANGED_LINE_NUMBER: 291
    FIRST_CHANGED_LINE_CONTENT:         const char *path;
    HUNK_LINES:
        gboolean base64 = FALSE;
        char *uri_string;
        GBytes *bytes;
+        const char *path;

        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 305
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }

        uri_string = g_uri_to_string (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-uri-utils.c
    HUNK_START_LINE_NUMBER: 301
    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,
    HUNK_START_LINE_CONTENT:         if (content_type)
    FIRST_CHANGED_LINE_NUMBER: 305
    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);
    HUNK_LINES:
        if (content_type)
            *content_type = NULL;

+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */
+        path = g_uri_get_path (soup_uri);
+        if (path[0] == '/' && path[1] == '/') {
+                g_uri_unref (soup_uri);
+                return NULL;
+        }

        uri_string = g_uri_to_string (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL },", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/uri-parsing-test.c
    HUNK_START_LINE_NUMBER: 141
    FUNCTION_SIGNATURE: static struct {
    HUNK_START_LINE_CONTENT:         { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
    FIRST_CHANGED_LINE_NUMBER: 144
    FIRST_CHANGED_LINE_CONTENT:         { "data:.///", NULL, NULL },
    HUNK_LINES:
        { "data:text/plain;base64,aGVsbG8=", "hello", "text/plain" },
        { "data:text/plain;base64,invalid=", "", "text/plain" },
        { "data:,", "", CONTENT_TYPE_DEFAULT },
+        { "data:.///", NULL, NULL },
+        { "data:/.//", NULL, NULL }"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:             guint index_pattern = 0;
    FIRST_CHANGED_LINE_NUMBER: 527
    FIRST_CHANGED_LINE_CONTENT: 			while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        guint index_pattern = 0;
        gboolean skip_row = FALSE;

-        while ((index_stream < resource_length) &&
+        while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c
    HUNK_START_LINE_NUMBER: 524
    FUNCTION_SIGNATURE: sniff_unknown (SoupContentSniffer *sniffer, GBytes *buffer,
    HUNK_START_LINE_CONTENT:             guint index_pattern = 0;
    FIRST_CHANGED_LINE_NUMBER: 527
    FIRST_CHANGED_LINE_CONTENT: 			while ((index_stream < resource_length - 1) &&
    HUNK_LINES:
        guint index_pattern = 0;
        gboolean skip_row = FALSE;

-        while ((index_stream < resource_length) &&
+        while ((index_stream < resource_length - 1) &&
            (index_pattern <= type_row->pattern_length)) {
            /* Skip insignificant white space ("WS" in the spec) */
            if (type_row->pattern[index_pattern] == ' ') {"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 530
    FUNCTION_SIGNATURE: soup_header_parse_quality_list (const char *header, GSList **unacceptable)
    HUNK_START_LINE_CONTENT:     GSList *unsorted;
    FIRST_CHANGED_LINE_NUMBER: 533
    FIRST_CHANGED_LINE_CONTENT: 	char *item, *semi;
    HUNK_LINES:
        GSList *unsorted;
        QualityItem *array;
        GSList *sorted, *iter;
-       char *item, *semi;
+       char *semi;
        const char *param, *equal, *value;
        double qval;
        int n;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 530
    FUNCTION_SIGNATURE: soup_header_parse_quality_list (const char *header, GSList **unacceptable)
    HUNK_START_LINE_CONTENT:     GSList *unsorted;
    FIRST_CHANGED_LINE_NUMBER: 533
    FIRST_CHANGED_LINE_CONTENT: 	char *item, *semi;
    HUNK_LINES:
        GSList *unsorted;
        QualityItem *array;
        GSList *sorted, *iter;
-       char *item, *semi;
+       char *semi;
        const char *param, *equal, *value;
        double qval;
        int n;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 543
    FUNCTION_SIGNATURE: soup_header_parse_quality_list (const char *header, GSList **unacceptable)
    HUNK_START_LINE_CONTENT:     unsorted = soup_header_parse_list (header);
    FIRST_CHANGED_LINE_NUMBER: 545
    FIRST_CHANGED_LINE_CONTENT: -       item = iter->data;
    HUNK_LINES:
        unsorted = soup_header_parse_list (header);
        array = g_new0 (QualityItem, g_slist_length (unsorted));
        for (iter = unsorted, n = 0; iter; iter = iter->next) {
-           item = iter->data;
            qval = 1.0;
-           for (semi = strchr (item, ';'); semi; semi = strchr (semi + 1, ';')) {
+           for (semi = strchr (iter->data, ';'); semi; semi = strchr (semi + 1, ';')) {
                param = skip_lws (semi + 1);
                if (*param != 'q')
                    continue;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 543
    FUNCTION_SIGNATURE: soup_header_parse_quality_list (const char *header, GSList **unacceptable)
    HUNK_START_LINE_CONTENT:     unsorted = soup_header_parse_list (header);
    FIRST_CHANGED_LINE_NUMBER: 545
    FIRST_CHANGED_LINE_CONTENT: -       item = iter->data;
    HUNK_LINES:
        unsorted = soup_header_parse_list (header);
        array = g_new0 (QualityItem, g_slist_length (unsorted));
        for (iter = unsorted, n = 0; iter; iter = iter->next) {
-           item = iter->data;
            qval = 1.0;
-           for (semi = strchr (item, ';'); semi; semi = strchr (semi + 1, ';')) {
+           for (semi = strchr (iter->data, ';'); semi; semi = strchr (semi + 1, ';')) {
                param = skip_lws (semi + 1);
                if (*param != 'q')
                    continue;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 577
    FUNCTION_SIGNATURE: soup_header_parse_quality_list (const char *header, GSList **unacceptable)
    HUNK_START_LINE_CONTENT:         if (qval == 0.0) {
    FIRST_CHANGED_LINE_NUMBER: 580
    FIRST_CHANGED_LINE_CONTENT: -                                   item);
    HUNK_LINES:
            if (qval == 0.0) {
                if (unacceptable) {
                    *unacceptable = g_slist_prepend (*unacceptable,
-                                                   item);
+                                                   g_steal_pointer (&iter->data));
                }
            } else {
-               array[n].item = item;
+               array[n].item = g_steal_pointer (&iter->data);
                array[n].qval = qval;
                n++;
            }
        }
-       g_slist_free (unsorted);
+       g_slist_free_full (unsorted, g_free);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-headers.c
    HUNK_START_LINE_NUMBER: 577
    FUNCTION_SIGNATURE: soup_header_parse_quality_list (const char *header, GSList **unacceptable)
    HUNK_START_LINE_CONTENT:         if (qval == 0.0) {
    FIRST_CHANGED_LINE_NUMBER: 580
    FIRST_CHANGED_LINE_CONTENT: -                                   item);
    HUNK_LINES:
            if (qval == 0.0) {
                if (unacceptable) {
                    *unacceptable = g_slist_prepend (*unacceptable,
-                                                   item);
+                                                   g_steal_pointer (&iter->data));
                }
            } else {
-               array[n].item = item;
+               array[n].item = g_steal_pointer (&iter->data);
                array[n].qval = qval;
                n++;
            }
        }
-       g_slist_free (unsorted);
+       g_slist_free_full (unsorted, g_free);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT: SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1234
    FIRST_CHANGED_LINE_CONTENT: +        /* Strip all credentials on cross-origin redirect. */
    HUNK_LINES:
        SOUP_ENCODING_NONE);
+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: libsoup/soup-session.c
    HUNK_START_LINE_NUMBER: 1230
    FUNCTION_SIGNATURE: soup_session_redirect_message (SoupSession *session,
    HUNK_START_LINE_CONTENT: SOUP_ENCODING_NONE);
    FIRST_CHANGED_LINE_NUMBER: 1234
    FIRST_CHANGED_LINE_CONTENT: +        /* Strip all credentials on cross-origin redirect. */
    HUNK_LINES:
        SOUP_ENCODING_NONE);
+        /* Strip all credentials on cross-origin redirect. */
+        if (!soup_uri_host_equal (soup_message_get_uri (msg), new_uri)) {
+                soup_message_headers_remove_common (soup_message_get_request_headers (msg), SOUP_HEADER_AUTHORIZATION);
+                soup_message_set_auth (msg, NULL);
+        }
+
        soup_message_set_request_host_from_uri (msg, new_uri);
    soup_message_set_uri (msg, new_uri);
    g_uri_unref (new_uri);"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: #include "test-utils.h"
    FIRST_CHANGED_LINE_NUMBER: 4
    FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
    HUNK_LINES:
        #include "test-utils.h"
+#include "soup-uri-utils-private.h"

    static const char *base_uri;
    static GMainLoop *loop;", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1
    FUNCTION_SIGNATURE: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
    HUNK_START_LINE_CONTENT: #include "test-utils.h"
    FIRST_CHANGED_LINE_NUMBER: 4
    FIRST_CHANGED_LINE_CONTENT: +#include "soup-uri-utils-private.h"
    HUNK_LINES:
        #include "test-utils.h"
+#include "soup-uri-utils-private.h"

    static const char *base_uri;
    static GMainLoop *loop;"}
{"question": "ORIGINAL_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT: soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
+
+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}
+
+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}
+
+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}
+
    int", "answer": "BACKPORTED_HUNK_DATA:
    FILE_PATH: tests/auth-test.c
    HUNK_START_LINE_NUMBER: 1916
    FUNCTION_SIGNATURE: do_missing_params_test (gconstpointer auth_header)
    HUNK_START_LINE_CONTENT: soup_test_server_quit_unref (server);
    FIRST_CHANGED_LINE_NUMBER: 1917
    FIRST_CHANGED_LINE_CONTENT: +static void
    HUNK_LINES:
        soup_test_server_quit_unref (server);
+
+static void
+redirect_server_callback (SoupServer        *server,
+                          SoupServerMessage *msg,
+                          const char        *path,
+                          GHashTable        *query,
+                          gpointer           user_data)
+{
+    static gboolean redirected = FALSE;
+
+    if (!redirected) {
+        char *redirect_uri = g_uri_to_string (user_data);
+        soup_server_message_set_redirect (msg, SOUP_STATUS_MOVED_PERMANENTLY, redirect_uri);
+        g_free (redirect_uri);
+        redirected = TRUE;
+        return;
+    }
+
+    g_assert_not_reached ();
+}
+
+static gboolean
+auth_for_redirect_callback (SoupMessage *msg, SoupAuth *auth, gboolean retrying, gpointer user_data)
+{
+    GUri *known_server_uri = user_data;
+
+    if (!soup_uri_host_equal (known_server_uri, soup_message_get_uri (msg)))
+        return FALSE;
+
+    soup_auth_authenticate (auth, "user", "good-basic");
+
+    return TRUE;
+}
+
+static void
+do_strip_on_crossorigin_redirect (void)
+{
+    SoupSession *session;
+    SoupMessage *msg;
+    SoupServer *server1, *server2;
+    SoupAuthDomain *auth_domain;
+    GUri *uri;
+    gint status;
+
+    server1 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+    server2 = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+
+    /* Both servers have the same credentials. */
+    auth_domain = soup_auth_domain_basic_new ("realm", "auth-test", "auth-callback", server_basic_auth_callback, NULL);
+    soup_auth_domain_add_path (auth_domain, "/");
+    soup_server_add_auth_domain (server1, auth_domain);
+    soup_server_add_auth_domain (server2, auth_domain);
+    g_object_unref (auth_domain);
+
+    /* Server 1 asks for auth, then redirects to Server 2. */
+    soup_server_add_handler (server1, NULL,
+                    redirect_server_callback,
+                   soup_test_server_get_uri (server2, "http", NULL), (GDestroyNotify)g_uri_unref);
+    /* Server 2 requires auth. */
+    soup_server_add_handler (server2, NULL, server_callback, NULL, NULL);
+
+    session = soup_test_session_new (NULL);
+    uri = soup_test_server_get_uri (server1, "http", NULL);
+    msg = soup_message_new_from_uri ("GET", uri);
+    /* The client only sends credentials for the host it knows. */
+    g_signal_connect (msg, "authenticate", G_CALLBACK (auth_for_redirect_callback), uri);
+
+    status = soup_test_session_send_message (session, msg);
+
+    g_assert_cmpint (status, ==, SOUP_STATUS_UNAUTHORIZED);
+
+    g_uri_unref (uri);
+    soup_test_server_quit_unref (server1);
+    soup_test_server_quit_unref (server2);
+}
+
    int"}
