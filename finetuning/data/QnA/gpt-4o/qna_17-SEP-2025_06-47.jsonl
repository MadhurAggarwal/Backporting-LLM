{"question": "What change was made to the handling of the 'expires' attribute in the 'parse_one_cookie' function in 'libsoup/cookies/soup-cookie.c'?", "answer": "Replaced 'soup_cookie_set_expires' with 'g_clear_pointer' and direct assignment of 'parse_date' to 'cookie->expires'."}
{"question": "What modification was made to the 'parse_one_cookie' function in 'libsoup/cookies/soup-cookie.c' regarding memory management?", "answer": "Added 'g_clear_pointer' to free the previous value of 'cookie->expires' before assigning a new value."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 72\n    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)\n    HUNK_START_LINE_CONTENT:     g_free (priv->cnonce);\n    FIRST_CHANGED_LINE_NUMBER: 75\n    FIRST_CHANGED_LINE_CONTENT:     +        g_free (priv->opaque);\n    HUNK_LINES:\n        g_free (priv->nonce);\n        g_free (priv->domain);\n        g_free (priv->cnonce);\n    +        g_free (priv->opaque);\n        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));\n        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 72\n    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)\n    HUNK_START_LINE_CONTENT:     g_free (priv->cnonce);\n    FIRST_CHANGED_LINE_NUMBER: 75\n    FIRST_CHANGED_LINE_CONTENT:     +        g_free (priv->opaque);\n    HUNK_LINES:\n        g_free (priv->nonce);\n        g_free (priv->domain);\n        g_free (priv->cnonce);\n    +        g_free (priv->opaque);\n        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));\n        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));"}
{"question": "What is the new version number of the 'libsoup' project in 'meson.build' file?", "answer": "Version updated to '3.6.1' from '3.6.0'."}
{"question": "What changes were made to the 'NEWS' file regarding the 'libsoup_uri_copy()' function?", "answer": "Added note about fixing 'soup_uri_copy()' reading port as a long instead of an int."}
{"question": "What changes were made to the 'NEWS' file regarding the 'soup_uri_decode_data_uri()' function?", "answer": "Added note about fixing possible NULL dereference and assertion on URLs with paths starting with '//'."}
{"question": "What changes were made to the 'NEWS' file regarding the 'SoupContentSniffer'?", "answer": "Added note about fixing possible overflow in 'SoupContentSniffer'."}
{"question": "What changes were made to the 'NEWS' file regarding the 'headers' parsing?", "answer": "Added note about being more robust against invalid input when parsing params."}
{"question": "What changes were made to the 'NEWS' file regarding the 'websocket' functionality?", "answer": "Added note about fixing possibility of being stuck in a read loop."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 669\n    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)\n    HUNK_START_LINE_CONTENT: pos = 3;\n    FIRST_CHANGED_LINE_NUMBER: 671\n    FIRST_CHANGED_LINE_CONTENT: if (pos >= resource_length)\n    HUNK_LINES:\n        pos = 3;\n\nlook_for_tag:\n-    if (pos > resource_length)\n+    if (pos >= resource_length)\n        goto text_html;\n\n    if (skip_insignificant_space (resource, &pos, resource_length))", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/content-sniffer/soup-content-sniffer.c\n    HUNK_START_LINE_NUMBER: 669\n    FUNCTION_SIGNATURE: sniff_feed_or_html (SoupContentSniffer *sniffer, GBytes *buffer)\n    HUNK_START_LINE_CONTENT: pos = 3;\n    FIRST_CHANGED_LINE_NUMBER: 671\n    FIRST_CHANGED_LINE_CONTENT: if (pos >= resource_length)\n    HUNK_LINES:\n        pos = 3;\n\nlook_for_tag:\n-    if (pos > resource_length)\n+    if (pos >= resource_length)\n        goto text_html;\n\n    if (skip_insignificant_space (resource, &pos, resource_length))"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: tests/sniffing-test.c\n    HUNK_START_LINE_NUMBER: 512\n    FUNCTION_SIGNATURE: main (int argc, char **argv)\n    HUNK_START_LINE_CONTENT: \"type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8\",\n    FIRST_CHANGED_LINE_NUMBER: 516\n    FIRST_CHANGED_LINE_CONTENT: /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n    HUNK_LINES:\n        \"type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8\",\n        do_sniffing_test);\n\n+        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n+        g_test_add_data_func (\"/sniffing/whitespace\",\n+                              \"type/text_html/whitespace.html => text/html\",\n+                              do_sniffing_test);\n\n        /* Test that disabling the sniffer works correctly */", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: tests/sniffing-test.c\n    HUNK_START_LINE_NUMBER: 512\n    FUNCTION_SIGNATURE: main (int argc, char **argv)\n    HUNK_START_LINE_CONTENT: \"type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8\",\n    FIRST_CHANGED_LINE_NUMBER: 516\n    FIRST_CHANGED_LINE_CONTENT: /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n    HUNK_LINES:\n        \"type/text_html; charset=UTF-8/test.html => text/html; charset=UTF-8\",\n        do_sniffing_test);\n\n+        /* Test hitting skip_insignificant_space() with number of bytes equaling resource_length. */\n+        g_test_add_data_func (\"/sniffing/whitespace\",\n+                              \"type/text_html/whitespace.html => text/html\",\n+                              do_sniffing_test);\n\n        /* Test that disabling the sniffer works correctly */"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT:     const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 290\n    FIRST_CHANGED_LINE_CONTENT:     const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 305\n    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 299\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:     if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 303\n    FIRST_CHANGED_LINE_CONTENT:     path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 72\n    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)\n    HUNK_START_LINE_CONTENT:     g_free (priv->cnonce);\n    FIRST_CHANGED_LINE_NUMBER: 75\n    FIRST_CHANGED_LINE_CONTENT:     +        g_free (priv->opaque);\n    HUNK_LINES:\n        g_free (priv->nonce);\n        g_free (priv->domain);\n        g_free (priv->cnonce);\n    +        g_free (priv->opaque);\n        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));\n        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/auth/soup-auth-digest.c\n    HUNK_START_LINE_NUMBER: 72\n    FUNCTION_SIGNATURE: soup_auth_digest_finalize (GObject *object)\n    HUNK_START_LINE_CONTENT:     g_free (priv->cnonce);\n    FIRST_CHANGED_LINE_NUMBER: 75\n    FIRST_CHANGED_LINE_CONTENT:     +        g_free (priv->opaque);\n    HUNK_LINES:\n        g_free (priv->nonce);\n        g_free (priv->domain);\n        g_free (priv->cnonce);\n    +        g_free (priv->opaque);\n        memset (priv->hex_urp, 0, sizeof (priv->hex_urp));\n        memset (priv->hex_a1, 0, sizeof (priv->hex_a1));"}
{"question": "What change was made to the description of the support forum in the README file?", "answer": "Updated from mailing list URL to Discourse forum URL."}
{"question": "Which lines in the README file were modified to replace the mailing list information?", "answer": "Lines 14-16 replaced with updated support forum information."}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 291\n    FIRST_CHANGED_LINE_CONTENT:         const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 286\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         gboolean base64 = FALSE;\n    FIRST_CHANGED_LINE_NUMBER: 291\n    FIRST_CHANGED_LINE_CONTENT:         const char *path;\n    HUNK_LINES:\n        gboolean base64 = FALSE;\n        char *uri_string;\n        GBytes *bytes;\n+        const char *path;\n\n        g_return_val_if_fail (uri != NULL, NULL);"}
{"question": "ORIGINAL_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 303\n    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;", "answer": "BACKPORTED_HUNK_DATA:\n    FILE_PATH: libsoup/soup-uri-utils.c\n    HUNK_START_LINE_NUMBER: 301\n    FUNCTION_SIGNATURE: soup_uri_decode_data_uri (const char *uri,\n    HUNK_START_LINE_CONTENT:         if (content_type)\n    FIRST_CHANGED_LINE_NUMBER: 303\n    FIRST_CHANGED_LINE_CONTENT:         path = g_uri_get_path (soup_uri);\n    HUNK_LINES:\n        if (content_type)\n            *content_type = NULL;\n\n+        /* g_uri_to_string() is picky about paths that start with `//` and will assert. */\n+        path = g_uri_get_path (soup_uri);\n+        if (path[0] == '/' && path[1] == '/') {\n+                g_uri_unref (soup_uri);\n+                return NULL;\n+        }\n+\n        uri_string = g_uri_to_string (soup_uri);\n        g_uri_unref (soup_uri);\n        if (!uri_string)\n            return NULL;"}
