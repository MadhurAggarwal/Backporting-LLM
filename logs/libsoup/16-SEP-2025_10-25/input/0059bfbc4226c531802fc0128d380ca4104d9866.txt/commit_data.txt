commit 0059bfbc4226c531802fc0128d380ca4104d9866
Author: Patrick Griffis <pgriffis@igalia.com>
Date:   Tue Dec 24 18:51:39 2024 -0600

    http2: Improve management of window sizes
    
    Currently we allow nghttp2 to manage window sizes automatically,
    what this means is when we read data from the network nghttp2 immediately
    counts this data as read and will request that we want more.
    
    However libsoup is an intermediate for other applications and the
    application may not have read this data yet, leaving a buffer in
    libsoup.
    
    By disabling the automatic management and only considering data
    consumed when the application reads from our buffer it will
    maintain a more reasonable size.
    
    Closes #406
    Closes #397

diff --git a/libsoup/http2/soup-body-input-stream-http2.c b/libsoup/http2/soup-body-input-stream-http2.c
index ec7dd3c8..bdef6d2b 100644
--- a/libsoup/http2/soup-body-input-stream-http2.c
+++ b/libsoup/http2/soup-body-input-stream-http2.c
@@ -59,6 +59,7 @@ G_DEFINE_FINAL_TYPE_WITH_CODE (SoupBodyInputStreamHttp2, soup_body_input_stream_
 
 enum {
         NEED_MORE_DATA,
+        READ_DATA,
         LAST_SIGNAL
 };
 
@@ -77,6 +78,19 @@ soup_body_input_stream_http2_new (void)
         return G_INPUT_STREAM (g_object_new (SOUP_TYPE_BODY_INPUT_STREAM_HTTP2, NULL));
 }
 
+gsize
+soup_body_input_stream_http2_get_buffer_size (SoupBodyInputStreamHttp2 *stream)
+{
+        SoupBodyInputStreamHttp2Private *priv;
+
+        g_return_val_if_fail (SOUP_IS_BODY_INPUT_STREAM_HTTP2 (stream), 0);
+
+        priv = soup_body_input_stream_http2_get_instance_private (stream);
+
+        g_assert (priv->len >= priv->pos);
+        return priv->len - priv->pos;
+}
+
 void
 soup_body_input_stream_http2_add_data (SoupBodyInputStreamHttp2 *stream,
                                        const guint8             *data,
@@ -108,6 +122,14 @@ soup_body_input_stream_http2_is_blocked (SoupBodyInputStreamHttp2 *stream)
         return priv->need_more_data_cancellable != NULL;
 }
 
+static gboolean
+have_more_data_coming (SoupBodyInputStreamHttp2 *stream)
+{
+        SoupBodyInputStreamHttp2Private *priv = soup_body_input_stream_http2_get_instance_private (stream);
+
+        return !priv->completed || priv->pos < priv->len;
+}
+
 static gssize
 soup_body_input_stream_http2_read_real (GInputStream  *stream,
                                         gboolean       blocking,
@@ -173,23 +195,29 @@ soup_body_input_stream_http2_read_real (GInputStream  *stream,
                 l = next;
         }
 
-        priv->pos += count;
+        gsize bytes_read = count - rest;
+        priv->pos += bytes_read;
 
-        /* We need to block until the read is completed.
-         * So emit a signal saying we need more data. */
-        if (count == 0 && blocking && !priv->completed) {
+        if (bytes_read > 0)
+                g_signal_emit (memory_stream, signals[READ_DATA], 0, bytes_read);
+
+        /* When doing blocking reads we must always request more data.
+         * Even when doing non-blocking, a read consuming data may trigger a new WINDOW_UPDATE. */
+        if (have_more_data_coming (memory_stream) && bytes_read == 0) {
                 GError *read_error = NULL;
                 g_signal_emit (memory_stream, signals[NEED_MORE_DATA], 0,
-                               blocking, cancellable, &read_error);
+                        blocking, cancellable, &read_error);
 
                 if (read_error) {
                         g_propagate_error (error, read_error);
                         return -1;
                 }
 
-                return soup_body_input_stream_http2_read_real (
-                        stream, blocking, buffer, read_count, cancellable, error
-                );
+                if (blocking) {
+                        return soup_body_input_stream_http2_read_real (
+                                stream, blocking, buffer, read_count, cancellable, error
+                        );
+                }
         }
 
         return count;
@@ -212,12 +240,11 @@ soup_body_input_stream_http2_read_nonblocking (GPollableInputStream  *stream,
                                                GError               **error)
 {
         SoupBodyInputStreamHttp2 *memory_stream = SOUP_BODY_INPUT_STREAM_HTTP2 (stream);
-        SoupBodyInputStreamHttp2Private *priv = soup_body_input_stream_http2_get_instance_private (memory_stream);
         GError *inner_error = NULL;
 
         gsize read = soup_body_input_stream_http2_read_real (G_INPUT_STREAM (stream), FALSE, buffer, count, NULL, &inner_error);
 
-        if (read == 0 && !priv->completed && !inner_error) {
+        if (read == 0 && have_more_data_coming (memory_stream) && !inner_error) {
                 g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK, _("Operation would block"));
                 return -1;
         }
@@ -253,6 +280,8 @@ soup_body_input_stream_http2_skip (GInputStream  *stream,
 
         count = MIN (count, priv->len - priv->pos);
         priv->pos += count;
+        if (count)
+                g_signal_emit (memory_stream, signals[READ_DATA], 0, count);
 
         /* Remove all skipped chunks */
         gsize offset = priv->start_offset;
@@ -439,4 +468,14 @@ soup_body_input_stream_http2_class_init (SoupBodyInputStreamHttp2Class *klass)
                               G_TYPE_ERROR,
                               2, G_TYPE_BOOLEAN,
                               G_TYPE_CANCELLABLE);
+
+        signals[READ_DATA] =
+                g_signal_new ("read-data",
+                              G_OBJECT_CLASS_TYPE (object_class),
+                              G_SIGNAL_RUN_FIRST,
+                              0,
+                              NULL, NULL,
+                              NULL,
+                              G_TYPE_NONE, 1,
+                              G_TYPE_UINT64);
 }
diff --git a/libsoup/http2/soup-body-input-stream-http2.h b/libsoup/http2/soup-body-input-stream-http2.h
index b55cd6f5..45c46a28 100644
--- a/libsoup/http2/soup-body-input-stream-http2.h
+++ b/libsoup/http2/soup-body-input-stream-http2.h
@@ -8,6 +8,8 @@ G_DECLARE_FINAL_TYPE (SoupBodyInputStreamHttp2, soup_body_input_stream_http2, SO
 
 GInputStream * soup_body_input_stream_http2_new        (void);
 
+gsize          soup_body_input_stream_http2_get_buffer_size (SoupBodyInputStreamHttp2 *stream);
+
 void           soup_body_input_stream_http2_add_data   (SoupBodyInputStreamHttp2 *stream,
                                                         const guint8             *data,
                                                         gsize                     size);
diff --git a/libsoup/http2/soup-client-message-io-http2.c b/libsoup/http2/soup-client-message-io-http2.c
index dbccd1d2..796a2850 100644
--- a/libsoup/http2/soup-client-message-io-http2.c
+++ b/libsoup/http2/soup-client-message-io-http2.c
@@ -510,13 +510,13 @@ io_read_ready (GObject                  *stream,
         if (conn)
                 soup_connection_set_in_use (conn, TRUE);
 
-        while (progress && nghttp2_session_want_read (io->session)) {
+        while (nghttp2_session_want_read (io->session) || nghttp2_session_want_write (io->session)) {
                 progress = io_read (io, FALSE, NULL, &error);
-                if (progress) {
-                        g_list_foreach (io->pending_io_messages,
-                                        (GFunc)soup_http2_message_data_check_status,
-                                        NULL);
-                }
+                g_list_foreach (io->pending_io_messages,
+                                (GFunc)soup_http2_message_data_check_status,
+                                NULL);
+                if (!progress || error)
+                        break;
         }
 
         if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
@@ -647,12 +647,27 @@ memory_stream_need_more_data_callback (SoupBodyInputStreamHttp2 *stream,
         SoupHTTP2MessageData *data = (SoupHTTP2MessageData*)user_data;
         GError *error = NULL;
 
-        if (nghttp2_session_want_read (data->io->session))
+        if (data->in_io_try_sniff_content)
+                return NULL;
+
+        if (nghttp2_session_want_read (data->io->session) || nghttp2_session_want_write (data->io->session))
                 io_read (data->io, blocking, cancellable, &error);
 
         return error;
 }
 
+static void
+memory_stream_read_data (SoupBodyInputStreamHttp2 *stream,
+                         guint64                   bytes_read,
+                         gpointer                  user_data)
+{
+        SoupHTTP2MessageData *data = (SoupHTTP2MessageData*)user_data;
+
+        h2_debug (data->io, data, "[BODY_STREAM] Consumed %" G_GUINT64_FORMAT " bytes", bytes_read);
+
+        NGCHECK (nghttp2_session_consume(data->io->session, data->stream_id, bytes_read));
+}
+
 static int
 on_begin_frame_callback (nghttp2_session        *session,
                          const nghttp2_frame_hd *hd,
@@ -680,6 +695,8 @@ on_begin_frame_callback (nghttp2_session        *session,
                         data->body_istream = soup_body_input_stream_http2_new ();
                         g_signal_connect (data->body_istream, "need-more-data",
                                           G_CALLBACK (memory_stream_need_more_data_callback), data);
+                        g_signal_connect (data->body_istream, "read-data",
+                                          G_CALLBACK (memory_stream_read_data), data);
 
                         g_assert (!data->decoded_data_istream);
                         data->decoded_data_istream = soup_session_setup_message_body_input_stream (data->item->session,
@@ -1986,17 +2003,18 @@ soup_client_message_io_http2_init (SoupClientMessageIOHTTP2 *io)
         nghttp2_session_callbacks_set_on_frame_send_callback (callbacks, on_frame_send_callback);
         nghttp2_session_callbacks_set_on_stream_close_callback (callbacks, on_stream_close_callback);
 
-#ifdef HAVE_NGHTTP2_OPTION_SET_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION
         nghttp2_option *option;
 
         nghttp2_option_new (&option);
+
+#ifdef HAVE_NGHTTP2_OPTION_SET_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION
         nghttp2_option_set_no_rfc9113_leading_and_trailing_ws_validation (option, 1);
-        NGCHECK (nghttp2_session_client_new2 (&io->session, callbacks, io, option));
-        nghttp2_option_del (option);
-#else
-        NGCHECK (nghttp2_session_client_new (&io->session, callbacks, io));
 #endif
+        nghttp2_option_set_no_auto_window_update (option, 1);
 
+        NGCHECK (nghttp2_session_client_new2 (&io->session, callbacks, io, option));
+
+        nghttp2_option_del (option);
         nghttp2_session_callbacks_del (callbacks);
 
         io->messages = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, (GDestroyNotify)soup_http2_message_data_free);
diff --git a/tests/http2-test.c b/tests/http2-test.c
index 39a14655..e244ca29 100644
--- a/tests/http2-test.c
+++ b/tests/http2-test.c
@@ -34,6 +34,9 @@ typedef struct {
 #define LARGE_N_CHARS 24
 #define LARGE_CHARS_REPEAT 1024
 
+// This just needs to be larger than our default window size in soup-connection.c
+#define REALLY_LARGE_BUFFER_SIZE 62914600
+
 static void
 setup_session (Test *test, gconstpointer data)
 {
@@ -553,6 +556,103 @@ do_paused_async_test (Test *test, gconstpointer data)
         g_uri_unref (uri);
 }
 
+static void
+on_send_for_buffer_test (GObject *object, GAsyncResult *result, gpointer user_data)
+{
+        SoupSession *session = SOUP_SESSION (object);
+        GError *error = NULL;
+        GInputStream **stream_out = user_data;
+
+        *stream_out = soup_session_send_finish (session, result, &error);
+
+        g_assert_no_error (error);
+        g_assert_nonnull (*stream_out);
+}
+
+static SoupBodyInputStreamHttp2 *
+get_body_stream_from_response (GInputStream *stream)
+{
+       return SOUP_BODY_INPUT_STREAM_HTTP2 (g_filter_input_stream_get_base_stream (G_FILTER_INPUT_STREAM (stream))); 
+}
+
+static void
+read_until_end_for_buffer_test (GObject *object, GAsyncResult *result, gpointer user_data)
+{
+        gboolean *finished = user_data;
+	gssize nread;
+        static char buffer[10240];
+
+	nread = g_input_stream_read_finish (G_INPUT_STREAM (object), result, NULL);
+        if (nread > 0) {
+                g_input_stream_read_async (G_INPUT_STREAM (object), buffer, sizeof (buffer), G_PRIORITY_DEFAULT, NULL, read_until_end_for_buffer_test, user_data);
+                return;
+        }
+
+        g_assert_cmpint (nread, ==, 0);
+        *finished = TRUE;
+}
+
+static void
+on_read_for_buffer_test (GObject *object, GAsyncResult *result, gpointer user_data)
+{
+	gssize *nread = user_data;
+
+	*nread = g_input_stream_read_finish (G_INPUT_STREAM (object), result, NULL);
+        g_assert_cmpint (*nread, >, 0);
+}
+
+static void
+do_flow_control_buffer_sizes (Test *test, gconstpointer data)
+{
+        GUri *uri;
+        SoupMessage *large_msg;
+        SoupMessage *small_msg;
+        GBytes *small_response;
+        GInputStream *response_stream = NULL;
+        static char buffer[1024] = { 0 };
+        gssize read_bytes = 0;
+        gsize buffer_size = 0;
+        gboolean finished = FALSE;
+
+        uri = g_uri_parse_relative (base_uri, "/larger-than-window", SOUP_HTTP_URI_FLAGS, NULL);
+        large_msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+        g_uri_unref (uri);
+        soup_session_send_async (test->session, large_msg, G_PRIORITY_DEFAULT, NULL, on_send_for_buffer_test, &response_stream);
+        while (!response_stream)
+                g_main_context_iteration (g_main_context_default(), TRUE);
+
+        g_input_stream_read_async (response_stream, buffer, sizeof (buffer), G_PRIORITY_DEFAULT, NULL, on_read_for_buffer_test, &read_bytes);
+        while (read_bytes == 0)
+                g_main_context_iteration (g_main_context_default(), TRUE);
+
+
+        buffer_size = soup_body_input_stream_http2_get_buffer_size (get_body_stream_from_response (response_stream));
+        // We have not already buffered the whole response.
+        g_assert_cmpint (buffer_size, <, REALLY_LARGE_BUFFER_SIZE);
+
+        uri = g_uri_parse_relative (base_uri, "/large", SOUP_HTTP_URI_FLAGS, NULL);
+        small_msg = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
+        g_uri_unref (uri);
+        small_response = soup_session_send_and_read (test->session, small_msg, NULL, NULL);
+        g_assert_nonnull(small_response);
+        g_bytes_unref (small_response);
+        g_object_unref (small_msg);
+
+        // The buffer could grow a little but shouldn't buffer the whole thing still.
+        buffer_size = soup_body_input_stream_http2_get_buffer_size (get_body_stream_from_response (response_stream));
+        g_assert_cmpint (buffer_size, <, REALLY_LARGE_BUFFER_SIZE);
+
+        g_input_stream_read_async (response_stream, buffer, sizeof (buffer), G_PRIORITY_DEFAULT, NULL, read_until_end_for_buffer_test, &finished);
+        while (!finished)
+                g_main_context_iteration (g_main_context_default(), TRUE);
+
+        // Entire buffer was read.
+        g_assert_cmpint (0, ==, soup_body_input_stream_http2_get_buffer_size (get_body_stream_from_response (response_stream)));
+
+        g_object_unref (large_msg);
+        g_object_unref (response_stream);
+}
+
 typedef struct {
         int connection;
         int stream;
@@ -1287,6 +1387,15 @@ server_handler (SoupServer        *server,
                 }
                 soup_message_body_append (response_body, SOUP_MEMORY_STATIC, "\0", 1);
 
+                soup_server_message_set_status (msg, SOUP_STATUS_OK, NULL);
+        } else if (strcmp (path, "/larger-than-window") == 0) {
+                char *big_data = g_malloc0 (REALLY_LARGE_BUFFER_SIZE);
+                GBytes *bytes = g_bytes_new_take (big_data, REALLY_LARGE_BUFFER_SIZE);
+
+                SoupMessageBody *response_body = soup_server_message_get_response_body (msg);
+                soup_message_body_append_bytes (response_body, bytes);
+                g_bytes_unref (bytes);
+
                 soup_server_message_set_status (msg, SOUP_STATUS_OK, NULL);
         } else if (strcmp (path, "/echo_query") == 0) {
                 const char *query_str = g_uri_get_query (soup_server_message_get_uri (msg));
@@ -1457,6 +1566,10 @@ main (int argc, char **argv)
                     setup_session,
                     do_flow_control_multi_message_async_test,
                     teardown_session);
+        g_test_add ("/http2/flow-control/buffer-size", Test, NULL,
+                    setup_session,
+                    do_flow_control_buffer_sizes,
+                    teardown_session);
         g_test_add ("/http2/connections", Test, NULL,
                     setup_session,
                     do_connections_test,