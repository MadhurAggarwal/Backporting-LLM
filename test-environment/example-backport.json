{
    "cve_number": "CVE-2025-4948",
    "cve_description": "\n    A flaw was found in the soup_multipart_new_from_message() function of the libsoup HTTP library, which is commonly used by GNOME and other applications to handle web communications. The issue occurs when the library processes specially crafted multipart messages. Due to improper validation, an internal calculation can go wrong, leading to an integer underflow. This can cause the program to access invalid memory and crash. As a result, any application or server using libsoup could be forced to exit unexpectedly, creating a denial-of-service (DoS) risk.\n    ",
    "upstream_patch": "\n        From f2f28afe0b3b2b3009ab67d6874457ec6bac70c0 Mon Sep 17 00:00:00 2001\n        From: Milan Crha <mcrha@redhat.com>\n        Date: Thu, 15 May 2025 17:49:11 +0200\n        Subject: [PATCH] soup-multipart: Verify boundary limits for multipart body\n\n        It could happen that the boundary started at a place which resulted into\n        a negative number, which in an unsigned integer is a very large value.\n        Check the body size is not a negative value before setting it.\n\n        Closes https://gitlab.gnome.org/GNOME/libsoup/-/issues/449\n\n        Part-of: <https://gitlab.gnome.org/GNOME/libsoup/-/merge_requests/463>\n        ---\n        libsoup/soup-multipart.c |  2 +-\n        tests/multipart-test.c   | 40 ++++++++++++++++++++++++++++++++++++++++\n        2 files changed, 41 insertions(+), 1 deletion(-)\n\n        diff --git a/libsoup/soup-multipart.c b/libsoup/soup-multipart.c\n        index 7b1e20cf..e526369e 100644\n        --- a/libsoup/soup-multipart.c\n        +++ b/libsoup/soup-multipart.c\n        @@ -204,7 +204,7 @@ soup_multipart_new_from_message (SoupMessageHeaders *headers,\n                */\n                part_body = g_bytes_new_from_bytes (body, // FIXME\n                                    split - body_data,\n        -\t\t\t\t\t\t    end - 2 - split);\n        +\t\t\t\t\t\t    end - 2 >= split ? end - 2 - split : 0);\n                g_ptr_array_add (multipart->bodies, part_body);\n        \n                start = end;\n        diff --git a/tests/multipart-test.c b/tests/multipart-test.c\n        index c4e996ae..e7c28dfb 100644\n        --- a/tests/multipart-test.c\n        +++ b/tests/multipart-test.c\n        @@ -527,6 +527,45 @@ test_multipart_bounds_bad (void)\n            g_bytes_unref (bytes);\n        }\n        \n        +static void\n        +test_multipart_too_large (void)\n        +{\n        +\tconst char *raw_body =\n        +\t\t\"-------------------\r\n\"\n        +\t\t\"-\n\"\n        +\t\t\"Cont\"\r\n\"\n        +\t\t\"Content-Tynt----e:nrQK\r\n\"\n        +\t\t\"Content-Disposition:   name=  form-; name=\"file\"; filename=\"ype:i/  -d; ----®\r\n\"\n        +\t\t\"Content-Typimag\u0001/png--\\\n\"\n        +\t\t\"\r\n\"\n        +\t\t\"---:\n\r\n\"\n        +\t\t\"\r\n\"\n        +\t\t\"-------------------------------------\r\n\"\n        +\t\t\"---------\r\n\"\n        +\t\t\"----------------------\";\n        +\tGBytes *body;\n        +\tGHashTable *params;\n        +\tSoupMessageHeaders *headers;\n        +\tSoupMultipart *multipart;\n        +\n        +\tparams = g_hash_table_new (g_str_hash, g_str_equal);\n        +\tg_hash_table_insert (params, (gpointer) \"boundary\", (gpointer) \"-----------------\");\n        +\theaders = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);\n        +\tsoup_message_headers_set_content_type (headers, \"multipart/form-data\", params);\n        +\tg_hash_table_unref (params);\n        +\n        +\tbody = g_bytes_new_static (raw_body, strlen (raw_body));\n        +\tmultipart = soup_multipart_new_from_message (headers, body);\n        +\tsoup_message_headers_unref (headers);\n        +\tg_bytes_unref (body);\n        +\n        +\tg_assert_nonnull (multipart);\n        +\tg_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);\n        +\tg_assert_true (soup_multipart_get_part (multipart, 0, &headers, &body));\n        +\tg_assert_cmpint (g_bytes_get_size (body), ==, 0);\n        +\tsoup_multipart_free (multipart);\n        +}\n        +\n        int\n        main (int argc, char **argv)\n        {\n        @@ -556,6 +595,7 @@ main (int argc, char **argv)\n            g_test_add_data_func (\"/multipart/async-small-reads\", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);\n            g_test_add_func (\"/multipart/bounds-good\", test_multipart_bounds_good);\n            g_test_add_func (\"/multipart/bounds-bad\", test_multipart_bounds_bad);\n        +\tg_test_add_func (\"/multipart/too-large\", test_multipart_too_large);\n        \n            ret = g_test_run ();\n        \n        -- \n        GitLab\n    ",
    "file_codes": {
        "libsoup/soup-multipart.c": "/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */\n/*\n * soup-multipart.c: multipart HTTP message bodies\n *\n * Copyright (C) 2008 Red Hat, Inc.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <string.h>\n\n#include \"soup-multipart.h\"\n#include \"soup-headers.h\"\n#include \"soup-message-headers-private.h\"\n#include \"soup.h\"\n\n/**\n * SoupMultipart:\n *\n * Represents a multipart HTTP message body, parsed according to the\n * syntax of RFC 2046.\n *\n * Of particular interest to HTTP are `multipart/byte-ranges` and\n * `multipart/form-data`,\n *\n * Although the headers of a #SoupMultipart body part will contain the\n * full headers from that body part, libsoup does not interpret them\n * according to MIME rules. For example, each body part is assumed to\n * have \"binary\" Content-Transfer-Encoding, even if its headers\n * explicitly state otherwise. In other words, don't try to use\n * #SoupMultipart for handling real MIME multiparts.\n *\n **/\n\nstruct _SoupMultipart {\n\tchar *mime_type, *boundary;\n\tGPtrArray *headers, *bodies;\n};\n\nstatic SoupMultipart *\nsoup_multipart_new_internal (char *mime_type, char *boundary)\n{\n\tSoupMultipart *multipart;\n\n\tmultipart = g_slice_new (SoupMultipart);\n\tmultipart->mime_type = mime_type;\n\tmultipart->boundary = boundary;\n\tmultipart->headers = g_ptr_array_new_with_free_func ((GDestroyNotify)soup_message_headers_unref);\n\tmultipart->bodies = g_ptr_array_new_with_free_func ((GDestroyNotify)g_bytes_unref);\n\n\treturn multipart;\n}\n\nstatic char *\ngenerate_boundary (void)\n{\n\tguint32 data[2];\n\n\tdata[0] = g_random_int ();\n\tdata[1] = g_random_int ();\n\n\t/* The maximum boundary string length is 69 characters, and a\n\t * stringified SHA256 checksum is 64 bytes long.\n\t */\n\treturn g_compute_checksum_for_data (G_CHECKSUM_SHA256,\n\t\t\t\t\t    (const guchar *)&data,\n\t\t\t\t\t    sizeof (data));\n}\n\n/**\n * soup_multipart_new:\n * @mime_type: the MIME type of the multipart to create.\n *\n * Creates a new empty #SoupMultipart with a randomly-generated\n * boundary string.\n *\n * Note that @mime_type must be the full MIME type, including \"multipart/\".\n *\n * See also: [ctor@Message.new_from_multipart].\n * \n * Returns: a new empty #SoupMultipart of the given @mime_type\n **/\nSoupMultipart *\nsoup_multipart_new (const char *mime_type)\n{\n\treturn soup_multipart_new_internal (g_strdup (mime_type),\n\t\t\t\t\t    generate_boundary ());\n}\n\nstatic const char *\nfind_boundary (const char *start, const char *end,\n\t       const char *boundary, int boundary_len)\n{\n\tconst char *b;\n\n\tfor (b = memchr (start, '-', end - start);\n\t     b && b + boundary_len + 4 < end;\n\t     b = memchr (b + 2, '-', end - (b + 2))) {\n\t\t/* Check for \"--boundary\" */\n\t\tif (b[1] != '-' ||\n\t\t    memcmp (b + 2, boundary, boundary_len) != 0)\n\t\t\tcontinue;\n\n\t\t/* Check that it's at start of line */\n\t\tif (!(b == start || (b[-1] == '\\n' && b[-2] == '\\r')))\n\t\t\tcontinue;\n\n\t\t/* Check for \"--\" or \"\\r\\n\" after boundary */\n\t\tif ((b[boundary_len + 2] == '-' && b[boundary_len + 3] == '-') ||\n\t\t    (b[boundary_len + 2] == '\\r' && b[boundary_len + 3] == '\\n'))\n\t\t\treturn b;\n\t}\n\treturn NULL;\n}\n\n/**\n * soup_multipart_new_from_message:\n * @headers: the headers of the HTTP message to parse\n * @body: the body of the HTTP message to parse\n *\n * Parses @headers and @body to form a new #SoupMultipart\n *\n * Returns: (nullable): a new #SoupMultipart (or %NULL if the\n *   message couldn't be parsed or wasn't multipart).\n **/\nSoupMultipart *\nsoup_multipart_new_from_message (SoupMessageHeaders *headers,\n\t\t\t\t GBytes             *body)\n{\n\tSoupMultipart *multipart;\n\tconst char *content_type, *boundary;\n\tGHashTable *params;\n\tint boundary_len;\n\tconst char *start, *split, *end, *body_end;\n\tSoupMessageHeaders *part_headers;\n\tGBytes *part_body;\n\n\tcontent_type = soup_message_headers_get_content_type (headers, &params);\n\tif (!content_type)\n\t\treturn NULL;\n\n\tboundary = g_hash_table_lookup (params, \"boundary\");\n\tif (strncmp (content_type, \"multipart/\", 10) != 0 || !boundary) {\n\t\tg_hash_table_destroy (params);\n\t\treturn NULL;\n\t}\n\n\tmultipart = soup_multipart_new_internal (\n\t\tg_strdup (content_type), g_strdup (boundary));\n\tg_hash_table_destroy (params);\n\n        gsize body_size;\n        const char *body_data = g_bytes_get_data (body, &body_size);\n\tbody_end = body_data + body_size;\n\tboundary = multipart->boundary;\n\tboundary_len = strlen (boundary);\n\n\t/* skip preamble */\n\tstart = find_boundary (body_data, body_end,\n\t\t\t       boundary, boundary_len);\n\tif (!start) {\n\t\tsoup_multipart_free (multipart);\n\t\treturn NULL;\n\t}\n\n\twhile (start[2 + boundary_len] != '-') {\n\t\tend = find_boundary (start + 2 + boundary_len, body_end,\n\t\t\t\t     boundary, boundary_len);\n\t\tif (!end) {\n\t\t\tsoup_multipart_free (multipart);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsplit = g_strstr_len (start, body_end - start, \"\\r\\n\\r\\n\");\n\t\tif (!split || split > end) {\n\t\t\tsoup_multipart_free (multipart);\n\t\t\treturn NULL;\n\t\t}\n\t\tsplit += 4;\n\n\t\t/* @start points to the start of the boundary line\n\t\t * preceding this part, and @split points to the end\n\t\t * of the headers / start of the body.\n\t\t *\n\t\t * We tell soup_headers_parse() to start parsing at\n\t\t * @start, because it skips the first line of the\n\t\t * input anyway (expecting it to be either a\n\t\t * Request-Line or Status-Line).\n\t\t */\n\t\tpart_headers = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);\n\t\tg_ptr_array_add (multipart->headers, part_headers);\n\t\tif (!soup_headers_parse (start, split - 2 - start,\n\t\t\t\t\t part_headers)) {\n\t\t\tsoup_multipart_free (multipart);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* @split, as previously mentioned, points to the\n\t\t * start of the body, and @end points to the start of\n\t\t * the following boundary line, which is to say 2 bytes\n\t\t * after the end of the body.\n\t\t */\n\t\tpart_body = g_bytes_new_from_bytes (body, // FIXME\n\t\t\t\t\t\t    split - body_data,\n\t\t\t\t\t\t    end - 2 - split);\n\t\tg_ptr_array_add (multipart->bodies, part_body);\n\n\t\tstart = end;\n\t}\n\n\treturn multipart;\n}\n\n/**\n * soup_multipart_get_length:\n * @multipart: a #SoupMultipart\n *\n * Gets the number of body parts in @multipart.\n *\n * Returns: the number of body parts in @multipart\n **/\nint\nsoup_multipart_get_length (SoupMultipart *multipart)\n{\n\treturn multipart->bodies->len;\n}\n\n/**\n * soup_multipart_get_part:\n * @multipart: a #SoupMultipart\n * @part: the part number to get (counting from 0)\n * @headers: (out) (transfer none): return location for the MIME part\n *   headers\n * @body: (out) (transfer none): return location for the MIME part\n *   body\n *\n * Gets the indicated body part from @multipart.\n *\n * Returns: %TRUE on success, %FALSE if @part is out of range (in\n *   which case @headers and @body won't be set)\n **/\ngboolean\nsoup_multipart_get_part (SoupMultipart *multipart, int part,\n\t\t\t SoupMessageHeaders **headers, GBytes **body)\n{\n\tif (part < 0 || part >= multipart->bodies->len)\n\t\treturn FALSE;\n\t*headers = multipart->headers->pdata[part];\n\t*body = multipart->bodies->pdata[part];\n\treturn TRUE;\n}\n\n/**\n * soup_multipart_append_part:\n * @multipart: a #SoupMultipart\n * @headers: the MIME part headers\n * @body: the MIME part body\n *\n * Adds a new MIME part to @multipart with the given headers and body.\n *\n * (The multipart will make its own copies of @headers and @body, so\n * you should free your copies if you are not using them for anything\n * else.)\n **/\nvoid\nsoup_multipart_append_part (SoupMultipart      *multipart,\n\t\t\t    SoupMessageHeaders *headers,\n\t\t\t    GBytes         *body)\n{\n\tSoupMessageHeaders *headers_copy;\n\tSoupMessageHeadersIter iter;\n\tconst char *name, *value;\n\n\t/* Copying @headers is annoying, but the alternatives seem\n\t * worse:\n\t *\n\t * 1) We don't want to use g_boxed_copy, because\n\t *    SoupMessageHeaders actually implements that as just a\n\t *    ref, which would be confusing since SoupMessageHeaders\n\t *    is mutable and the caller might modify @headers after\n\t *    appending it.\n\t *\n\t * 2) We can't change SoupMessageHeaders to not just do a ref\n\t *    from g_boxed_copy, because that would break language\n\t *    bindings (which need to be able to hold a ref on\n\t *    soup_message_get_request_headers (msg), but don't want\n         *    to duplicate it).\n\t *\n\t * 3) We don't want to steal the reference to @headers,\n\t *    because then we'd have to either also steal the\n\t *    reference to @body (which would be inconsistent with\n\t *    other GBytes methods), or NOT steal the reference to\n\t *    @body, in which case there'd be inconsistency just\n\t *    between the two arguments of this method!\n\t */\n\theaders_copy = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);\n\tsoup_message_headers_iter_init (&iter, headers);\n\twhile (soup_message_headers_iter_next (&iter, &name, &value))\n\t\tsoup_message_headers_append (headers_copy, name, value);\n\n\tg_ptr_array_add (multipart->headers, headers_copy);\n\tg_ptr_array_add (multipart->bodies, g_bytes_ref (body));\n}\n\n/**\n * soup_multipart_append_form_string:\n * @multipart: a multipart (presumably of type \"multipart/form-data\")\n * @control_name: the name of the control associated with @data\n * @data: the body data\n *\n * Adds a new MIME part containing @data to @multipart.\n *\n * Uses \"Content-Disposition: form-data\", as per the HTML forms specification.\n **/\nvoid\nsoup_multipart_append_form_string (SoupMultipart *multipart,\n\t\t\t\t   const char *control_name, const char *data)\n{\n\tGBytes *body;\n\n\tbody = g_bytes_new (data, strlen (data));\n\tsoup_multipart_append_form_file (multipart, control_name,\n\t\t\t\t\t NULL, NULL, body);\n\tg_bytes_unref (body);\n}\n\n/**\n * soup_multipart_append_form_file:\n * @multipart: a multipart (presumably of type \"multipart/form-data\")\n * @control_name: the name of the control associated with this file\n * @filename: (nullable): the name of the file, or %NULL if not known\n * @content_type: (nullable): the MIME type of the file, or %NULL if not known\n * @body: the file data\n *\n * Adds a new MIME part containing @body to @multipart\n *\n * Uses \"Content-Disposition: form-data\", as per the HTML forms specification.\n **/\nvoid\nsoup_multipart_append_form_file (SoupMultipart *multipart,\n\t\t\t\t const char *control_name, const char *filename,\n\t\t\t\t const char *content_type, GBytes *body)\n{\n\tSoupMessageHeaders *headers;\n\tGString *disposition;\n\n\theaders = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);\n\tdisposition = g_string_new (\"form-data; \");\n\tsoup_header_g_string_append_param_quoted (disposition, \"name\", control_name);\n\tif (filename) {\n\t\tg_string_append (disposition, \"; \");\n\t\tsoup_header_g_string_append_param_quoted (disposition, \"filename\", filename);\n\t}\n\tsoup_message_headers_append_common (headers, SOUP_HEADER_CONTENT_DISPOSITION,\n                                            disposition->str);\n\tg_string_free (disposition, TRUE);\n\n\tif (content_type) {\n\t\tsoup_message_headers_append_common (headers, SOUP_HEADER_CONTENT_TYPE,\n                                                    content_type);\n\t}\n\n\tg_ptr_array_add (multipart->headers, headers);\n\tg_ptr_array_add (multipart->bodies, g_bytes_ref (body));\n}\n\n/**\n * soup_multipart_to_message:\n * @multipart: a #SoupMultipart\n * @dest_headers: the headers of the HTTP message to serialize @multipart to\n * @dest_body: (out): the body of the HTTP message to serialize @multipart to\n *\n * Serializes @multipart to @dest_headers and @dest_body.\n **/\nvoid\nsoup_multipart_to_message (SoupMultipart      *multipart,\n\t\t\t   SoupMessageHeaders *dest_headers,\n\t\t\t   GBytes            **dest_body)\n{\n\tSoupMessageHeaders *part_headers;\n\tGBytes *part_body;\n\tSoupMessageHeadersIter iter;\n\tconst char *name, *value;\n\tGString *str;\n\tGHashTable *params;\n\tguint i;\n\n\tparams = g_hash_table_new (g_str_hash, g_str_equal);\n\tg_hash_table_insert (params, \"boundary\", multipart->boundary);\n\tsoup_message_headers_set_content_type (dest_headers,\n\t\t\t\t\t       multipart->mime_type,\n\t\t\t\t\t       params);\n\tg_hash_table_destroy (params);\n\n\tstr = g_string_new (NULL);\n\n\tfor (i = 0; i < multipart->bodies->len; i++) {\n\t\tpart_headers = multipart->headers->pdata[i];\n\t\tpart_body = multipart->bodies->pdata[i];\n\n\t\tif (i > 0)\n\t\t\tg_string_append (str, \"\\r\\n\");\n\t\tg_string_append (str, \"--\");\n\t\tg_string_append (str, multipart->boundary);\n\t\tg_string_append (str, \"\\r\\n\");\n\t\tsoup_message_headers_iter_init (&iter, part_headers);\n\t\twhile (soup_message_headers_iter_next (&iter, &name, &value))\n\t\t\tg_string_append_printf (str, \"%s: %s\\r\\n\", name, value);\n\t\tg_string_append (str, \"\\r\\n\");\n\t\tg_string_append_len (str,\n\t\t\t\t     g_bytes_get_data (part_body, NULL),\n\t\t\t\t     g_bytes_get_size (part_body));\n\t}\n\n\tg_string_append (str, \"\\r\\n--\");\n\tg_string_append (str, multipart->boundary);\n\tg_string_append (str, \"--\\r\\n\");\n\n\t/* (The \"\\r\\n\" after the close-delimiter seems wrong according\n\t * to my reading of RFCs 2046 and 2616, but that's what\n\t * everyone else does.)\n\t */\n\n\t*dest_body = g_string_free_to_bytes (str);\n}\n\n/**\n * soup_multipart_free:\n * @multipart: a #SoupMultipart\n *\n * Frees @multipart.\n **/\nvoid\nsoup_multipart_free (SoupMultipart *multipart)\n{\n\tg_free (multipart->mime_type);\n\tg_free (multipart->boundary);\n\tg_ptr_array_free (multipart->headers, TRUE);\n\tg_ptr_array_free (multipart->bodies, TRUE);\n\n\tg_slice_free (SoupMultipart, multipart);\n}\n\nstatic SoupMultipart *\nsoup_multipart_copy (SoupMultipart *multipart)\n{\n\tSoupMultipart *copy;\n\tguint i;\n\n\tcopy = soup_multipart_new_internal (g_strdup (multipart->mime_type),\n\t\t\t\t\t    g_strdup (multipart->boundary));\n\tfor (i = 0; i < multipart->bodies->len; i++) {\n\t\tsoup_multipart_append_part (copy,\n\t\t\t\t\t    multipart->headers->pdata[i],\n\t\t\t\t\t    multipart->bodies->pdata[i]);\n\t}\n\treturn copy;\n}\n\nG_DEFINE_BOXED_TYPE (SoupMultipart, soup_multipart, soup_multipart_copy, soup_multipart_free)\n",
        "tests/multipart-test.c": "/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */\n/*\n * Copyright (C) 2011 Collabora Ltd.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"test-utils.h\"\n\n#ifndef G_OS_WIN32\n#include <unistd.h>\n#endif\n\n#define READ_BUFFER_SIZE 8192\n\ntypedef enum {\n\tNO_MULTIPART,\n\tSYNC_MULTIPART,\n\tASYNC_MULTIPART,\n\tASYNC_MULTIPART_SMALL_READS\n} MultipartMode;\n\nchar *buffer;\nSoupSession *session;\nchar *base_uri_string;\nGUri *base_uri;\nSoupMultipartInputStream *multipart;\nunsigned passes;\nGMainLoop *loop;\n\n\n/* This payload contains 4 different responses.\n *\n * First, a text/html response with a Content-Length (31);\n * Second, a response lacking Content-Type with Content-Length (11);\n * Third, a text/css response with no Content-Length;\n * Fourth, same as the third, but with different content;\n */\nconst char *payload = \\\n\t\"--cut-here\\r\\n\" \\\n\t\"Content-Type: text/html\\n\"\n\t\"Content-Length: 30\\r\\n\" \\\n\t\"\\r\\n\" \\\n\t\"<html><body>Hey!</body></html>\" \\\n\t\"\\r\\n--cut-here\\r\\n\" \\\n\t\"Content-Length: 10\\r\\n\" \\\n\t\"\\r\\n\" \\\n\t\"soup rocks\" \\\n\t\"\\r\\n--cut-here\\r\\n\" \\\n\t\"Content-Type: text/css\\r\\n\" \\\n\t\"\\r\\n\" \\\n\t\".soup { before: rocks; }\" \\\n\t\"\\r\\n--cut-here\\n\" /* Tests boundary ending in a single \\n. */ \\\n\t\"Content-Type: text/css\\r\\n\" \\\n\t\"\\r\\n\" \\\n\t\"#soup { background-color: black; }\" \\\n        \"\\r\\n--cut-here--\";\n\nstatic void\nserver_callback (SoupServer        *server,\n\t\t SoupServerMessage *msg,\n\t\t const char        *path,\n\t\t GHashTable        *query,\n\t\t gpointer           data)\n{\n\tSoupMessageHeaders *response_headers;\n\tSoupMessageBody *response_body;\n\n\tif (soup_server_message_get_method (msg) != SOUP_METHOD_GET) {\n\t\tsoup_server_message_set_status (msg, SOUP_STATUS_NOT_IMPLEMENTED, NULL);\n\t\treturn;\n\t}\n\n\tsoup_server_message_set_status (msg, SOUP_STATUS_OK, NULL);\n\n\tresponse_headers = soup_server_message_get_response_headers (msg);\n\tsoup_message_headers_append (response_headers,\n\t\t\t\t     \"Content-Type\", \"multipart/x-mixed-replace; boundary=cut-here\");\n\n\tresponse_body = soup_server_message_get_response_body (msg);\n\tsoup_message_body_append (response_body,\n\t\t\t\t  SOUP_MEMORY_STATIC,\n\t\t\t\t  payload,\n\t\t\t\t  strlen (payload));\n\n\tsoup_message_body_complete (response_body);\n}\n\nstatic void\ncontent_sniffed (SoupMessage *msg, char *content_type, GHashTable *params, int *sniffed_count)\n{\n\t*sniffed_count = *sniffed_count + 1;\n\tdebug_printf (2, \"  content-sniffed -> %s\\n\", content_type);\n}\n\nstatic void\ncheck_is_next (gboolean is_next)\n{\n\tsoup_test_assert (is_next,\n\t\t\t  \"expected a header, but there are no more headers\");\n}\n\nstatic void\ngot_headers (SoupMessage *msg, int *headers_count)\n{\n\tSoupMessageHeadersIter iter;\n\tgboolean is_next;\n\tconst char* name, *value;\n\n\t*headers_count = *headers_count + 1;\n\n\tsoup_message_headers_iter_init (&iter, soup_message_get_response_headers (msg));\n\n\tis_next = soup_message_headers_iter_next (&iter, &name, &value);\n\tcheck_is_next (is_next);\n\n\tif (g_str_equal (name, \"Date\")) {\n\t\tis_next = soup_message_headers_iter_next (&iter, &name, &value);\n\t\tcheck_is_next (is_next);\n\t}\n\n\tg_assert_cmpstr (name, ==, \"Content-Type\");\n\tg_assert_cmpstr (value, ==, \"multipart/x-mixed-replace; boundary=cut-here\");\n}\n\nstatic void\nread_cb (GObject *source, GAsyncResult *asyncResult, gpointer data)\n{\n\tGInputStream *stream = G_INPUT_STREAM (source);\n\tGError *error = NULL;\n\tgssize bytes_read;\n\n\tbytes_read = g_input_stream_read_finish (stream, asyncResult, &error);\n\tg_assert_no_error (error);\n\tif (error) {\n\t\tg_object_unref (stream);\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\tif (!bytes_read) {\n\t\tg_input_stream_close (stream, NULL, &error);\n\t\tg_assert_no_error (error);\n\t\tg_object_unref (stream);\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\tg_input_stream_read_async (stream, buffer, READ_BUFFER_SIZE,\n\t\t\t\t   G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t   read_cb, NULL);\n}\n\nstatic void\nno_multipart_handling_cb (GObject *source, GAsyncResult *res, gpointer data)\n{\n\tSoupSession *session = SOUP_SESSION (source);\n\tGError *error = NULL;\n\tGInputStream* in;\n\n\tin = soup_session_send_finish (session, res, &error);\n\tg_assert_no_error (error);\n\tif (error) {\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\tg_input_stream_read_async (in, buffer, READ_BUFFER_SIZE,\n\t\t\t\t   G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t   read_cb, NULL);\n}\n\nstatic void\nmultipart_close_part_cb (GObject *source, GAsyncResult *res, gpointer data)\n{\n\tGInputStream *in = G_INPUT_STREAM (source);\n\tGError *error = NULL;\n\n\tg_input_stream_close_finish (in, res, &error);\n\tg_assert_no_error (error);\n}\n\nstatic void multipart_next_part_cb (GObject *source,\n\t\t\t\t    GAsyncResult *res,\n\t\t\t\t    gpointer data);\n\nstatic void\ncheck_read (gsize nread, unsigned passes)\n{\n\tswitch (passes) {\n\tcase 0:\n\t\tg_assert_cmpint (nread, ==, 30);\n\t\tbreak;\n\tcase 1:\n\t\tg_assert_cmpint (nread, ==, 10);\n\t\tbreak;\n\tcase 2:\n\t\tg_assert_cmpint (nread, ==, 24);\n\t\tbreak;\n\tcase 3:\n\t\tg_assert_cmpint (nread, ==, 34);\n\t\tbreak;\n\tdefault:\n\t\tsoup_test_assert (FALSE, \"unexpected read of size: %d\", (int)nread);\n\t\tbreak;\n\t}\n}\n\nstatic void\nmultipart_read_cb (GObject *source, GAsyncResult *asyncResult, gpointer data)\n{\n\tGInputStream *in = G_INPUT_STREAM (source);\n\tGError *error = NULL;\n\tstatic gssize bytes_read_for_part = 0;\n\tgssize bytes_read;\n\n\tbytes_read = g_input_stream_read_finish (in, asyncResult, &error);\n\tg_assert_no_error (error);\n\tif (error) {\n\t\tg_input_stream_close_async (in, G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t\t    multipart_close_part_cb, NULL);\n\t\tg_object_unref (in);\n\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\t/* Read 0 bytes - try to start reading another part. */\n\tif (!bytes_read) {\n\t\tcheck_read (bytes_read_for_part, passes);\n\t\tbytes_read_for_part = 0;\n\t\tpasses++;\n\n\t\tg_input_stream_close_async (in, G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t\t    multipart_close_part_cb, NULL);\n\t\tg_object_unref (in);\n\n\t\tsoup_multipart_input_stream_next_part_async (multipart, G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t\t\t\t     multipart_next_part_cb, NULL);\n\t\treturn;\n\t}\n\n\tbytes_read_for_part += bytes_read;\n\tg_input_stream_read_async (in, buffer, READ_BUFFER_SIZE,\n\t\t\t\t   G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t   multipart_read_cb, NULL);\n}\n\nstatic void\ncheck_headers (SoupMultipartInputStream* multipart, unsigned passes)\n{\n\tSoupMessageHeaders *headers;\n\tSoupMessageHeadersIter iter;\n\tgboolean is_next;\n\tconst char *name, *value;\n\n\theaders = soup_multipart_input_stream_get_headers (multipart);\n\tsoup_message_headers_iter_init (&iter, headers);\n\n\tswitch (passes) {\n\tcase 0:\n\t\tis_next = soup_message_headers_iter_next (&iter, &name, &value);\n\t\tcheck_is_next (is_next);\n\n\t\tg_assert_cmpstr (name, ==, \"Content-Type\");\n\t\tg_assert_cmpstr (value, ==, \"text/html\");\n\n\t\tis_next = soup_message_headers_iter_next (&iter, &name, &value);\n\t\tcheck_is_next (is_next);\n\n\t\tg_assert_cmpstr (name, ==, \"Content-Length\");\n\t\tg_assert_cmpstr (value, ==, \"30\");\n\n\t\tbreak;\n\tcase 1:\n\t\tis_next = soup_message_headers_iter_next (&iter, &name, &value);\n\t\tcheck_is_next (is_next);\n\n\t\tg_assert_cmpstr (name, ==, \"Content-Length\");\n\t\tg_assert_cmpstr (value, ==, \"10\");\n\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tis_next = soup_message_headers_iter_next (&iter, &name, &value);\n\t\tcheck_is_next (is_next);\n\n\t\tg_assert_cmpstr (name, ==, \"Content-Type\");\n\t\tg_assert_cmpstr (value, ==, \"text/css\");\n\n\t\tbreak;\n\tdefault:\n\t\tsoup_test_assert (FALSE, \"unexpected part received\");\n\t\tbreak;\n\t}\n}\n\nstatic void\nmultipart_next_part_cb (GObject *source, GAsyncResult *res, gpointer data)\n{\n\tGError *error = NULL;\n\tGInputStream *in;\n\tgsize read_size = READ_BUFFER_SIZE;\n\n\tg_assert (SOUP_MULTIPART_INPUT_STREAM (source) == multipart);\n\n\tin = soup_multipart_input_stream_next_part_finish (multipart, res, &error);\n\tg_assert_no_error (error);\n\tif (error) {\n\t\tg_clear_error (&error);\n\t\tg_object_unref (multipart);\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\tif (!in) {\n\t\tg_assert_cmpint (passes, ==, 4);\n\t\tg_object_unref (multipart);\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\tcheck_headers (multipart, passes);\n\n\tif (g_object_get_data (G_OBJECT (multipart), \"multipart-small-reads\"))\n\t\tread_size = 4;\n\n\tg_input_stream_read_async (in, buffer, read_size,\n\t\t\t\t   G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t   multipart_read_cb, data);\n}\n\nstatic void\nmultipart_handling_cb (GObject *source, GAsyncResult *res, gpointer data)\n{\n\tSoupMessage *message;\n\tSoupSession *session = SOUP_SESSION (source);\n\tGError *error = NULL;\n\tGInputStream *in;\n\n\tin = soup_session_send_finish (session, res, &error);\n\tg_assert_no_error (error);\n\tif (error) {\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\tmessage = soup_session_get_async_result_message (session, res);\n\tmultipart = soup_multipart_input_stream_new (message, in);\n\tg_object_unref (in);\n\n\tif (g_object_get_data (G_OBJECT (message), \"multipart-small-reads\"))\n\t\tg_object_set_data (G_OBJECT (multipart), \"multipart-small-reads\", GINT_TO_POINTER(1));\n\n\tsoup_multipart_input_stream_next_part_async (multipart, G_PRIORITY_DEFAULT, NULL,\n\t\t\t\t\t\t     multipart_next_part_cb, NULL);\n}\n\nstatic void\nsync_multipart_handling_cb (GObject *source, GAsyncResult *res, gpointer data)\n{\n\tSoupMessage *message;\n\tSoupSession *session = SOUP_SESSION (source);\n\tGError *error = NULL;\n\tGInputStream *in;\n\tchar buffer[READ_BUFFER_SIZE];\n\tgsize bytes_read;\n\n\tin = soup_session_send_finish (session, res, &error);\n\tg_assert_no_error (error);\n\tif (error) {\n\t\tg_main_loop_quit (loop);\n\t\treturn;\n\t}\n\n\tmessage = soup_session_get_async_result_message (session, res);\n\tmultipart = soup_multipart_input_stream_new (message, in);\n\tg_object_unref (in);\n\n\twhile (TRUE) {\n\t\tin = soup_multipart_input_stream_next_part (multipart, NULL, &error);\n\t\tg_assert_no_error (error);\n\t\tif (error) {\n\t\t\tg_clear_error (&error);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!in)\n\t\t\tbreak;\n\n\t\tcheck_headers (multipart, passes);\n\n\t\tg_input_stream_read_all (in, (void*)buffer, sizeof (buffer), &bytes_read, NULL, &error);\n\t\tg_assert_no_error (error);\n\t\tif (error) {\n\t\t\tg_clear_error (&error);\n\t\t\tg_object_unref (in);\n\t\t\tbreak;\n\t\t}\n\n\t\tcheck_read (bytes_read, passes);\n\n\t\tpasses++;\n\t\tg_object_unref (in);\n\t}\n\n\tg_assert_cmpint (passes, ==, 4);\n\n\tg_main_loop_quit (loop);\n\tg_object_unref (multipart);\n}\n\nstatic void\ntest_multipart (gconstpointer data)\n{\n\tint headers_expected = 1, sniffed_expected = 1;\n\tMultipartMode multipart_mode = GPOINTER_TO_INT (data);\n\tSoupMessage *msg;\n\tint headers_count = 0;\n\tint sniffed_count = 0;\n\tGHashTable *params;\n\tconst char *content_type;\n\tgboolean message_is_multipart = FALSE;\n\n\tmsg = soup_message_new (\"GET\", base_uri_string);\n\n\t/* This is used to track the number of parts. */\n\tpasses = 0;\n\n\t/* Force the server to close the connection. */\n\tsoup_message_headers_append (soup_message_get_request_headers (msg),\n\t\t\t\t     \"Connection\", \"close\");\n\n\tg_signal_connect (msg, \"got_headers\",\n\t\t\t  G_CALLBACK (got_headers), &headers_count);\n\n\tg_signal_connect (msg, \"content-sniffed\",\n\t\t\t  G_CALLBACK (content_sniffed), &sniffed_count);\n\n\tloop = g_main_loop_new (NULL, TRUE);\n\n\tif (multipart_mode == ASYNC_MULTIPART)\n\t\tsoup_session_send_async (session, msg, 0, NULL, multipart_handling_cb, NULL);\n\telse if (multipart_mode == ASYNC_MULTIPART_SMALL_READS) {\n\t\tg_object_set_data (G_OBJECT (msg), \"multipart-small-reads\", GINT_TO_POINTER(1));\n\t\tsoup_session_send_async (session, msg, 0, NULL, multipart_handling_cb, NULL);\n\t} else if (multipart_mode == SYNC_MULTIPART)\n\t\tsoup_session_send_async (session, msg, 0, NULL, sync_multipart_handling_cb, NULL);\n\telse\n\t\tsoup_session_send_async (session, msg, 0, NULL, no_multipart_handling_cb, NULL);\n\n\tg_main_loop_run (loop);\n\n\tcontent_type = soup_message_headers_get_content_type (soup_message_get_response_headers (msg), &params);\n\n\tif (content_type &&\n\t    g_str_has_prefix (content_type, \"multipart/\") &&\n\t    g_hash_table_lookup (params, \"boundary\")) {\n\t\tmessage_is_multipart = TRUE;\n\t}\n\tg_clear_pointer (&params, g_hash_table_unref);\n\n\tg_assert_true (message_is_multipart);\n\tg_assert_cmpint (headers_count, ==, headers_expected);\n\tg_assert_cmpint (sniffed_count, ==, sniffed_expected);\n\n\tg_object_unref (msg);\n\tg_main_loop_unref (loop);\n\tloop = NULL;\n}\n\nstatic void\ntest_multipart_bounds_good (void)\n{\n\t#define TEXT \"line1\\r\\nline2\"\n\tSoupMultipart *multipart;\n\tSoupMessageHeaders *headers, *set_headers = NULL;\n\tGBytes *bytes, *set_bytes = NULL;\n\tconst char *raw_data = \"--123\\r\\nContent-Type: text/plain;\\r\\n\\r\\n\" TEXT \"\\r\\n--123--\\r\\n\";\n\tgboolean success;\n\n\theaders = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);\n\tsoup_message_headers_append (headers, \"Content-Type\", \"multipart/mixed; boundary=\\\"123\\\"\");\n\n\tbytes = g_bytes_new (raw_data, strlen (raw_data));\n\n\tmultipart = soup_multipart_new_from_message (headers, bytes);\n\n\tg_assert_nonnull (multipart);\n\tg_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);\n\tsuccess = soup_multipart_get_part (multipart, 0, &set_headers, &set_bytes);\n\tg_assert_true (success);\n\tg_assert_nonnull (set_headers);\n\tg_assert_nonnull (set_bytes);\n\tg_assert_cmpint (strlen (TEXT), ==, g_bytes_get_size (set_bytes));\n\tg_assert_cmpstr (\"text/plain\", ==, soup_message_headers_get_content_type (set_headers, NULL));\n\tg_assert_cmpmem (TEXT, strlen (TEXT), g_bytes_get_data (set_bytes, NULL), g_bytes_get_size (set_bytes));\n\n\tsoup_message_headers_unref (headers);\n\tg_bytes_unref (bytes);\n\n\tsoup_multipart_free (multipart);\n\n\t#undef TEXT\n}\n\nstatic void\ntest_multipart_bounds_bad (void)\n{\n\tSoupMultipart *multipart;\n\tSoupMessageHeaders *headers;\n\tGBytes *bytes;\n\tconst char *raw_data = \"--123\\r\\nContent-Type: text/plain;\\r\\nline1\\r\\nline2\\r\\n--123--\\r\\n\";\n\n\theaders = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);\n\tsoup_message_headers_append (headers, \"Content-Type\", \"multipart/mixed; boundary=\\\"123\\\"\");\n\n\tbytes = g_bytes_new (raw_data, strlen (raw_data));\n\n\t/* it did read out of raw_data/bytes bounds */\n\tmultipart = soup_multipart_new_from_message (headers, bytes);\n\tg_assert_null (multipart);\n\n\tsoup_message_headers_unref (headers);\n\tg_bytes_unref (bytes);\n}\n\nint\nmain (int argc, char **argv)\n{\n\tSoupServer *server;\n\tint ret;\n\n\ttest_init (argc, argv, NULL);\n\n\tbuffer = g_malloc (READ_BUFFER_SIZE);\n\n\tserver = soup_test_server_new (SOUP_TEST_SERVER_DEFAULT);\n\tsoup_server_add_handler (server, NULL, server_callback, NULL, NULL);\n\tbase_uri = soup_test_server_get_uri (server, \"http\", NULL);\n\tbase_uri_string = g_uri_to_string (base_uri);\n\n\t/* FIXME: I had to raise the number of connections allowed here, otherwise I\n\t * was hitting the limit, which indicates some connections are not dying.\n\t */\n\tsession = soup_test_session_new (\"max-conns\", 20,\n\t\t\t\t\t \"max-conns-per-host\", 20,\n\t\t\t\t\t NULL);\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_CONTENT_SNIFFER);\n\n\tg_test_add_data_func (\"/multipart/no\", GINT_TO_POINTER (NO_MULTIPART), test_multipart);\n\tg_test_add_data_func (\"/multipart/sync\", GINT_TO_POINTER (SYNC_MULTIPART), test_multipart);\n\tg_test_add_data_func (\"/multipart/async\", GINT_TO_POINTER (ASYNC_MULTIPART), test_multipart);\n\tg_test_add_data_func (\"/multipart/async-small-reads\", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);\n\tg_test_add_func (\"/multipart/bounds-good\", test_multipart_bounds_good);\n\tg_test_add_func (\"/multipart/bounds-bad\", test_multipart_bounds_bad);\n\n\tret = g_test_run ();\n\n\tg_uri_unref (base_uri);\n\tg_free (base_uri_string);\n\tg_free (buffer);\n\n\tsoup_test_session_abort_unref (session);\n\tsoup_test_server_quit_unref (server);\n\n\ttest_cleanup ();\n\treturn ret;\n}\n"
    },
    "output": "From 9045f1ae252a5bbda8b51335c81aca009c753838 Mon Sep 17 00:00:00 2001\nFrom: Milan Crha <mcrha@redhat.com>\nDate: Thu, 15 May 2025 17:49:11 +0200\nSubject: [PATCH] soup-multipart: Verify boundary limits for multipart body\n\nIt could happen that the boundary started at a place which resulted into\na negative number, which in an unsigned integer is a very large value.\nCheck the body size is not a negative value before setting it.\n\nCloses https://gitlab.gnome.org/GNOME/libsoup/-/issues/449\n\nPart-of: <https://gitlab.gnome.org/GNOME/libsoup/-/merge_requests/463>\n---\n libsoup/soup-multipart.c |  2 +-\n tests/multipart-test.c   | 40 ++++++++++++++++++++++++++++++++++++++++\n 2 files changed, 41 insertions(+), 1 deletion(-)\n\ndiff --git a/libsoup/soup-multipart.c b/libsoup/soup-multipart.c\nindex 102ce37..a587fe7 100644\n--- a/libsoup/soup-multipart.c\n+++ b/libsoup/soup-multipart.c\n@@ -204,7 +204,7 @@ soup_multipart_new_from_message (SoupMessageHeaders *headers,\n \t\t */\n \t\tpart_body = g_bytes_new_from_bytes (body, // FIXME\n \t\t\t\t\t\t    split - body_data,\n-\t\t\t\t\t\t    end - 2 - split);\n+\t\t\t\t\t\t    end - 2 >= split ? end - 2 - split : 0);\n \t\tg_ptr_array_add (multipart->bodies, part_body);\n \n \t\tstart = end;\ndiff --git a/tests/multipart-test.c b/tests/multipart-test.c\nindex ab5f41c..a3a0b36 100644\n--- a/tests/multipart-test.c\n+++ b/tests/multipart-test.c\n@@ -527,6 +527,45 @@ test_multipart_bounds_bad (void)\n \tg_bytes_unref (bytes);\n }\n \n+static void\n+test_multipart_too_large (void)\n+{\n+\tconst char *raw_body =\n+\t\t\"-------------------\\r\\n\"\n+\t\t\"-\\n\"\n+\t\t\"Cont\\\"\\r\\n\"\n+\t\t\"Content-Tynt----e:n\\x8erQK\\r\\n\"\n+\t\t\"Content-Disposition:   name=  form-; name=\\\"file\\\"; filename=\\\"ype:i/  -d; ----\\xae\\r\\n\"\n+\t\t\"Content-Typimag\\x01/png--\\\\\\n\"\n+\t\t\"\\r\\n\"\n+\t\t\"---:\\n\\r\\n\"\n+\t\t\"\\r\\n\"\n+\t\t\"-------------------------------------\\r\\n\"\n+\t\t\"---------\\r\\n\"\n+\t\t\"----------------------\";\n+\tGBytes *body;\n+\tGHashTable *params;\n+\tSoupMessageHeaders *headers;\n+\tSoupMultipart *multipart;\n+\n+\tparams = g_hash_table_new (g_str_hash, g_str_equal);\n+\tg_hash_table_insert (params, (gpointer) \"boundary\", (gpointer) \"-----------------\");\n+\theaders = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);\n+\tsoup_message_headers_set_content_type (headers, \"multipart/form-data\", params);\n+\tg_hash_table_unref (params);\n+\n+\tbody = g_bytes_new_static (raw_body, strlen (raw_body));\n+\tmultipart = soup_multipart_new_from_message (headers, body);\n+\tsoup_message_headers_unref (headers);\n+\tg_bytes_unref (body);\n+\n+\tg_assert_nonnull (multipart);\n+\tg_assert_cmpint (soup_multipart_get_length (multipart), ==, 1);\n+\tg_assert_true (soup_multipart_get_part (multipart, 0, &headers, &body));\n+\tg_assert_cmpint (g_bytes_get_size (body), ==, 0);\n+\tsoup_multipart_free (multipart);\n+}\n+\n int\n main (int argc, char **argv)\n {\n@@ -556,6 +595,7 @@ main (int argc, char **argv)\n \tg_test_add_data_func (\"/multipart/async-small-reads\", GINT_TO_POINTER (ASYNC_MULTIPART_SMALL_READS), test_multipart);\n \tg_test_add_func (\"/multipart/bounds-good\", test_multipart_bounds_good);\n \tg_test_add_func (\"/multipart/bounds-bad\", test_multipart_bounds_bad);\n+\tg_test_add_func (\"/multipart/too-large\", test_multipart_too_large);\n \n \tret = g_test_run ();\n \n-- \n2.45.4\n\n"
}